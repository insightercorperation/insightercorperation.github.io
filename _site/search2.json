[
  
    {
      "title"    : "kubernetes를 이용한 서비스 무중단 배포",
      "category" : "",
      "tags"     : "intro",
      "url"      : "/2018/12/24/kubernetes-deploy/",
      "date"     : "2018-12-24 10:00:00 +0900",
      "content"   : "<p>Kubernetes는 컨테이너 오케스트레이션 영역에서 거의 표준으로 자리 잡은 오픈소스 시스템입니다. kubernetes를 사용하게 되면 여러대의 노드를 하나의 클러스터로 묶어서 사용가능하게 됩니다. 클러스터를 구성하는 노드들중에 일부에 장애가 발생하더라도 장애가 난 곳에 있던 컨테이너가 kubernetes에 의해 다른 정상상태의 노드로 옮겨가게 되어서 컨테이너로 제공하던 서비스에 지장이 없이 서비스가 지속될 수 있게 해줍니다. 그래서 실제로 서비스를 운영할 때는 컨테이너만을 단독으로 사용하기 보다는 이런 오케스트레이터와 함께 사용하는 경우가 많습니다.</p>\n\n<p>kubernetes를 사용하면 배포를 보다 편리하게 할 수 있다는 장점도 있습니다. 앱을 실행할 컨테이너만 준비해서 kubernetes에 제출하면 kubernetes가 알아서 배포절차를 진행합니다. 카카오에서 컨테이너 플랫폼을 운영하면서 가장 많이 받는 질문중 하나가 “배포중에 트래픽 유실은 없나요?” 입니다. 트래픽이 큰 서비스를 운영하면서 서비스의 품질을 유지하려면 배포중에도 트래픽 유실이 없어야 합니다. 이 글에서는 kubernetes를 사용해서 배포했을때 트래픽 유실이 없게하기 위해서 어떤 점들을 유의해야 하는지 알아보도록 하겠습니다.</p>\n\n<h2 id=\"kubernetes-pod-service-ingress-관계\">kubernetes pod, service, ingress 관계</h2>\n<p>먼저 kubernetes로 트래픽이 들어오는 구조를 살펴보도록 하겠습니다. kubernetes클러스터 내부에 있는 pod까지 트래픽이 도달하는 경로는 대략 다음과 같습니다.\n<img src=\"/files/kubernetes-traffic.jpg\" alt=\"\" /></p>\n\n<p>kubernetes는 별도의 클러스터 네트워크를 구성해서 이뤄지는 경우가 많기 때문에 외부에서 클러스터 내부에서 실행중인 pod에 접근하기 위해서는 인입되는 트래픽을 클러스터 내부까지 전달해줄 LB역할을 해줄 매개체가 필요한데요. AWS, GCP, Azure같은 Public cloud를 사용할때는 거기서 제공해주는 LB를 사용하면 되지만, 내부에 구축할때는 일반적으로 앞의 그림에 있는 ingress-controller를 사용합니다. ingress-controller에도 여러가지 종류가 있지만 이 글에서는 일반적인 nginx ingress controller를 기준으로 이야기하겠습니다. Kubernetes 내부에서 pod간 통신을 위해서는 중간에 service를 두고 통신하게 되는데요. ingress를 설정할때 역시 개별 pod들을 이용하는게 아니라 pod와 연결된 service를 설정하도록 되어 있습니다. 다음 ingress 설정을 보시면 serviceName으로 ingress를 통해서 연결하려는 서비스를 지정한 걸 확인할 수 있습니다.</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /testpath\n        backend:\n          serviceName: test\n          servicePort: 80\n</code></pre></div></div>\n<p>이렇게 설정되면 실제 nginx-ingress-controller는 이 service를 통해서 pod에 연결하는게 아니라 이 service에 연결된 pod의 정보를 가져와서 직접 nginx config로 설정하게 됩니다. 그래서 위의 그림에서는 service를 이용하긴하지만 직접 service를 거쳐서 통신하는건 아니라는 의미에서 service영역을 점선으로 표시했습니다.</p>\n\n<h2 id=\"kubernetes-pod-배포시-기본-구조\">kubernetes pod 배포시 기본 구조</h2>\n<p>앞에서 서비스 트래픽이 실제 어떻게 pod까지 전달되는지 알아봤습니다. 이제 실서비스에서 트래픽이 흘러가고 있는 와중에 pod를 어떻게 무중단으로 배포할 수 있는지 알아보도록 하겠습니다. 우선 pod가 배포되면 pod 교체가 어떻게 일어나는지 살펴보도록 하겠습니다. 정상적인 경우라면 아래 그림처럼 새로운 pod(v2)가 생성되고 헬스체크가 성공한 후에 트래픽이 pod(v2)쪽으로 흘러가게 됩니다. 그 후에 pod(v1) 쪽으로 가던 트래픽이 제거된 후 pod(v1)이 제거 됩니다.\n<img src=\"/files/kubernetes-deploy-pod-normal.gif\" alt=\"\" /></p>\n\n<p>이 과정에서 고려해야 할 부분들이 몇 군데 있습니다.</p>\n\n<h2 id=\"kubernetes-배포시-고려해야할-컨테이너-구성\">kubernetes 배포시 고려해야할 컨테이너 구성</h2>\n\n<p>Kubernetes 가 대부분의 배포 절차를 잘 수행해 주지만 컨테이너 내부에서도 종료될때 graceful shutdown구현이 필요합니다. 새로운 pod가 실행되고 이전 pod를 종료할때 kubernetes에서 노드의 컨테이너를 관리하는 프로세스인 kubelet은 먼저 pod에 SIGTERM 신호를 보내게 됩니다. 컨테이너에서 SIGTERM을 받았을때 기존에 처리중이던 요청에 대한 처리를 완료하고 새로운 요청을 받지 않도록 개발되어 있어야 합니다. 그렇지 않으면 아래 그림처럼 트래픽은 아직 Pod(v1)쪽으로 가고 있는데 Pod(v1)이 종료되어 버려서 아직 ingress-controller의 설정이 갱신되기 전에 pod(v1)으로 가는 요청들은 에러를 내게 됩니다. kubelet에서 pod에 SIGTERM을 보낸후에 일정시간동안 graceful shutdown이 되지 않는다면 강제로 SIGKILL을 보내서 pod를 종료하게 됩니다. 이 대기 기간은 terminationGracePeriodSeconds 으로 설정해 줄 수 있고 기본 대기 시간은 30초 입니다.\n<img src=\"/files/kubernetes-deploy-pod-error.gif\" alt=\"\" /></p>\n\n<p>SIGTERM 수신 뒤 즉시 종료 : 17.44% Request 502 error\n<img src=\"/files/kubernetes-sigterm01.png\" alt=\"\" /></p>\n\n<p>SIGTERM 시그널 처리시 : 무중단 배포 가능\n<img src=\"/files/kubernetes-sigterm02.png\" alt=\"\" /></p>\n\n<h2 id=\"kubernetes-배포시-고려해야할-kubernetes-옵션\">kubernetes 배포시 고려해야할 kubernetes 옵션</h2>\n\n<p>컨테이너가 SIGTERM을 고려해서 잘 만들어져 있다면 kubernetes에서 배포 과정에 어떤 옵션들을 활용할 수 있는지 살펴보겠습니다.</p>\n\n<p>먼저 pod의 롤링업데이트를 위한 maxSurge와 maxUnavailable 설정 옵션입니다. deployment를 이용해서 배포할 때 maxSurge는 deployment에 설정되어 있는 기본 pod개수보다 여분의 pod가 몇개가 더 추가될 수 있는지를 설정할 수 있습니다. maxUnavailable는 업데이트하는 동안 몇 개의 pod가 이용 불가능하게 되어도 되는지를 설정하는데 사용됩니다. 이 두개의 옵션을 운영중인 서비스의 특성에 맞게 적절히 조절해 주어야지 항상 일정 개수 이상의 pod가 이용가능하게 되기 때문에 배포중 트래픽 유실이 없게 됩니다. 둘 다 한꺼번에 0으로 설정되면 pod가 존재하지 않는 경우가 발생하기 때문에 한꺼번에 0으로 설정할 수는 없습니다.</p>\n\n<p>그 다음으로는 pod의 readinessProbe 설정입니다. kubernetes에서는 pod의 헬스체크를 확인하기 위해서 2가지 상태체크 옵션을 주고 있습니다. livenessProbe와 readinessProbe입니다. livenessProbe는 컨테이너가 살아 있는지 확인하는 역할을 하고 이 헬스체크가 실패하면 kubelet이 컨테이너를 죽이게 됩니다. 그리고 컨테이너의 restart policy에 따라 컨테이너가 재시작됩니다. 무중단 배포에서 신경써서 봐야할 설정은 readinessProbe입니다. readinessProbe는 실제로 컨테이너가 서비스 요청을 처리할 준비가 되었는지를 확인하는데 사용됩니다. readinessProbe가 ok상태여야지 이 pod와 연결된 service에 pod의 ip가 추가되고 트래픽을 받을 수 있게 됩니다. 자바 프로세스 같은 경우는 프로세스가 올라와서 livenessProbe가 ok상태가 되더라도 초기화 과정이 오래 걸리기 때문에 readinessProbe를 따로 설정하지 않을때에 아직 준비되지 않은 컨테이너로 요청이 가서 응답을 제대로 하지 못하고 실패할 수 있습니다. 그런 경우를 방지하기 위해서 실제 서비스가 준비된 상태인지를 확인할 수 있는 readinessProbe를 잘 설정해 주어야 합니다.</p>\n\n<p>경우에 따라서는 앱 자체가 readinessProbe를 설정해주기 어려운 상황일 수도 있습니다. 그럴때는 .spec.minReadySeconds 옵션을 이용하면 어느정도 readinessProbe와 비슷한 효과를 낼 수 있습니다. .spec.minReadySeconds은 pod의 status가 ready가 될때까지의 최소대기시간입니다. 그래서 pod가 실행되고나서 .spec.minReadySeconds에 설정된 시간동안은 트래픽을 받지 않습니다. 그렇기 때문에 readinessProbe를 설정하기 어렵고 초기화 시간이 오래 걸리는 컨테이너에 대해서 사용하면 컨테이너가 준비될때까지 일정시간동안 트래픽을 받지않고 대기할 수 있기 때문에 유용하게 사용할 수 있습니다. 하지만, readinessProbe가 완료되면 .spec.minReadySeconds에 설정된 시간이 아직 남아 있더라고도 무시되고 트래픽을 보내게 됩니다. .spec.minReadySeconds의 기본값은 0입니다.</p>\n\n<p>MinReadySeconds 옵션 : pod status 가 ready 로 업데이트 될 때 까지 최소 대기 시간, 그 전까지 서비스에서 트래픽 받지 않음\n<img src=\"/files/kubernetes-minreadysecond01.png\" alt=\"\" /></p>\n\n<p>Readiness Check 가 완료 되면 MinReadySeconds 설정은 무시된다.\n<img src=\"/files/kubernetes-minreadysecond02.png\" alt=\"\" /></p>\n\n<p>pod가 종료될때 graceful shutdown을 구현하지 못하는 경우도 있을 수 있습니다. 앱이 사용하는 언어나 프레임워크가 지원하지 않는 경우도 있고, 오래된 레거시라서 앱을 수정하지 못한채 컨테이너로 올려야되는 경우도 있을 수 있습니다. 이런 경우에는 prestop hook을 이용할 수 있습니다. kubernetes에서는 pod 라이프사이클중에 hook을 설정할 수 있습니다. pod가 실행되고난 직후 실행하는 poststart hook과 pod가 종료되기 직전 실행되는 prestop hook입니다. prestop 훅은 pod에 SIGTERM을 보내기 전에 실행되기 때문에 prestop을 이용하면 앱과 별개로 graceful shutdown의 효과를 내게 할 수도 있습니다. Prestop 훅의 실행이 완료되기 전까지는 컨테이너에 SIGTERM을 보내지 않기 때문에 앱의 구현과는 별개로 종료되기 전에 대기시간을 주는 것도 가능해 지게 됩니다. 하지만 이렇게 prestop 훅으로 대기시간을 주더라도 terminationGracePeriodSeconds 시간을 초과한다면 프로세스 종료가 일어날 수 있으니 염두에 두고 사용해야 합니다.\n<img src=\"/files/kubernetes-prestop-hook.png\" alt=\"\" /></p>\n\n<blockquote>\n  <p>위 내용은 카카오 사내 컨테이너 오케스트레이션 서비스인 DKOS를 운영하던 중 많이 나오는 문의사항을 토대로 배포시 고려해야 할 kubernetes 구조와 옵션 등을 살펴봤습니다.\nDKOS는 클라우드디플로이셀의 hardy.jung, dennig.hong, scott.vim, heimer.j등이 함께 운영해오고 있습니다.</p>\n</blockquote>\n"
    } ,
  
    {
      "title"    : "2019 카카오 블라인드 공채 2차 오프라인 코딩 테스트 문제 해설",
      "category" : "",
      "tags"     : "kakao and recruitment",
      "url"      : "/2018/10/23/kakao-blind-recruitment-round-2/",
      "date"     : "2018-10-23 10:00:00 +0900",
      "content"   : "<p>지난 10월 6일(토) 2019 블라인드 공채 오프라인 2차 코딩테스트가 진행되었습니다. 작년에는 8시간 동안 온라인으로 진행한 것과는 달리 오프라인으로 5시간 동안 치러졌는데요, 어떤 의도로 출제하였는지 살펴보겠습니다.</p>\n\n<h2 id=\"작년-2차-코딩테스트-회고\">작년 2차 코딩테스트 회고</h2>\n\n<p>작년 문제 출제 의도를 기억하시는지요?</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>온라인 2차 코딩 테스트 문제 출제 위원회에서는,\n- 탄탄한 기본기를 바탕으로 새로운 것을 빠르게 습득하는 역량\n- 요구사항을 꼼꼼하게 분석하고, 트레이드오프를 고려하여 디자인하여 구현하는 역량\n- 결과를 모니터링하며 점진적으로 개선해나가는 역량\n을 테스트할 수 있도록 2차 문제에 녹여내고자 하였습니다.\n</code></pre></div></div>\n\n<p>작년 문제에는 매우 많은 장치가 숨겨져 있었으나 정작 요구사항을 그대로 구현하기만 해도 합격선인 8만 점을 얻기에는 충분했었습니다.</p>\n\n<p>그리하여 올해는 시스템 디자인 역량을 좀 더 중점적으로 평가하고자 하였습니다.</p>\n\n<h2 id=\"엘리베이터-시뮬레이션\">엘리베이터 시뮬레이션</h2>\n\n<p>올해 오프라인 2차 테스트 문제는 다수의 엘리베이터(1대~4대)를 제어하는 시스템을 구현하는 것입니다. 핵심 구현에 집중할 수 있도록 엘리베이터 동작 및 상태는 서버에서 관리하고, 서버와 통신은 작년과 같이 REST API 및 JSON 포맷으로 주고받도록 하였습니다.</p>\n\n<p>지원자는 주어진 빌딩별 승객 트래픽을 분석하여 가정 적합한 엘리베이터 제어 알고리즘을 구현해야 합니다.</p>\n\n<p>지원자가 제어할 엘리베이터 시스템은 다음과 같습니다.</p>\n\n<h3 id=\"timestamp-시간\">Timestamp (시간)</h3>\n\n<ul>\n  <li>엘리베이터 시스템은 가상의 시간을 사용하며 <code class=\"highlighter-rouge\">timestamp</code>라 부른다.</li>\n  <li>Timestamp는 0부터 시작하고 엘리베이터에 명령을 내릴 때마다 1씩 증가한다.</li>\n</ul>\n\n<h3 id=\"call-승객\">Call (승객)</h3>\n\n<ul>\n  <li>승객이 엘리베이터 탑승을 위해 보내는 요청, 방향 버튼을 누르는 행위를 call이라 표현한다. Call에는 탑승하려는 층과 목적지 층이 포함된다.</li>\n  <li>어떤 승객을 태우거나 내려줄지도 엘리베이터 제어 시스템이 결정해야 한다. 승객은 스스로 타거나 내리지 않는다.</li>\n  <li>내리려는 층과 다른 층에 승객을 내려주면 다시 엘리베이터를 타기 위해 대기한다.</li>\n</ul>\n\n<h3 id=\"엘리베이터\">엘리베이터</h3>\n\n<ul>\n  <li>엘리베이터는 여러 대가 존재하며 모두 사용할 수도 있고 일부만 사용해도 된다.</li>\n  <li>엘리베이터에 명령을 내려 각각의 엘리베이터를 층을 이동하거나 멈추고, 문을 열 거나 닫고, 승객을 태우거나 내려 줄 수 있다.</li>\n  <li>엘리베이터는 정원이 있어 정해진 수 이상의 승객을 태울 수 없다.</li>\n  <li>엘리베이터에는 현재 상태를 표현하는 status가 있으며, 값으로는 <code class=\"highlighter-rouge\">STOPPED</code>, <code class=\"highlighter-rouge\">OPENED</code>, <code class=\"highlighter-rouge\">UPWARD</code>, <code class=\"highlighter-rouge\">DOWNWARD</code>가 있다.</li>\n  <li>사용할 수 있는 명령은 다음과 같다.</li>\n</ul>\n\n<table>\n  <thead>\n    <tr>\n      <th>명령</th>\n      <th>설명</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code class=\"highlighter-rouge\">STOP</code></td>\n      <td>엘리베이터를 멈춘다. 현재 층에 머무르기 원하는 경우 <code class=\"highlighter-rouge\">STOP</code> 명령을 통해 머무를 수 있다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">UP</code></td>\n      <td>엘리베이터를 한 층 올린다. 최상층인 경우 현재 층을 유지한다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">DOWN</code></td>\n      <td>엘리베이터를 한 층 내린다. 1층인 경우 1층을 유지한다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">OPEN</code></td>\n      <td>엘리베이터의 문을 연다. 엘리베이터의 문이 열린 상태를 유지하기 위해서는 <code class=\"highlighter-rouge\">OPEN</code> 명령을 사용한다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">CLOSE</code></td>\n      <td>엘리베이터의 문을 닫는다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">ENTER</code></td>\n      <td>엘리베이터에 승객을 태운다.</td>\n    </tr>\n    <tr>\n      <td><code class=\"highlighter-rouge\">EXIT</code></td>\n      <td>엘리베이터의 승객을 내린다. 목적지가 아닌 곳에서 내린 경우, <strong>OnCall API</strong>의 <code class=\"highlighter-rouge\">calls</code>에 내린 층과 내린 시점의 timestamp로 변경되어 다시 들어가게 된다.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>명령에 따른 status 전환을 그림과 표로 표현하면 아래와 같다.</p>\n\n<p><a href=\"https://t1.kakaocdn.net/welcome/2019/round2/diagram.jpeg\"><img src=\"https://t1.kakaocdn.net/welcome/2019/round2/diagram.jpeg\" alt=\"State diagram of Car\" height=\"70%\" width=\"70%\" /></a></p>\n\n<h2 id=\"문제의-특징-및-의도\">문제의 특징 및 의도</h2>\n\n<p>엘리베이터 1대의 동작은 대부분 지원자에게 친숙할 것입니다. 우리가 실생활에서 자주 접하는 엘리베이터 알고리즘은 “collective control”, “elevator algorithm” 등으로 불리는데 아래와 같이 2가지 규칙으로 구성됩니다.</p>\n\n<ol>\n  <li>엘리베이터 내에 탑승객이 있거나 현재 진행 방향의 앞쪽에 같은 진행 방향으로 이동하고자 하는 승객이 있으면, 현재의 방향을 유지한다.</li>\n  <li>현재 진행 방향의 요청들을 전부 처리하고 나면, 반대 방향의 요청을 처리하기 위해 방향을 전환한다. 만약 반대 방향의 요청이 없다면 멈추어 요청을 기다린다.</li>\n</ol>\n\n<p>간단하고 직관적인 알고리즘입니다. 운영체제 수업을 열심히 들은 학생이라면 디스크 스케줄링 알고리즘 중 하나인 look 알고리즘을 떠올릴 수도 있겠습니다.</p>\n\n<p>반면, 복수의 엘리베이터를 제어하기 위해서는 추가로 승객의 요청을 어느 엘리베이터에 할당할 것인지를 결정해야 합니다. 얼핏 보면 간단해 보이는 이 요구사항의 추가로 시스템은 제법 복잡해지게 됩니다. 어느 엘리베이터에 승객을 할당하는 것이 효율적인지 비용 계산을 해야 하고, 승객이 어디에 탑승하고 있는지를 관리해야 합니다. 층별로 구역을 나누어 운행한다면(홀/짝, 고층/저층 분리 운영 등) 환승 기능도 구현해야 합니다.</p>\n\n<p>1대의 엘리베이터 제어는 쉽고 간단해 보이지만, 3문제를 모두 풀기 위해서는 반드시 복수 엘리베이터를 제어해야 합니다. 또한 각 문제의 승객 패턴도 다르고, 승객 패턴에 따라 효율적으로 엘리베이터를 구성해야 합니다. 따라서 시스템 디자인 시 다양한 엘리베이터 알고리즘을 실험할 수 있도록 추상화 &amp; 모듈화를 통해 변경에 유연하도록 디자인해야 합니다. 실제 내부 모의 검증 시에도 문제 요구사항 분석 없이 1대만 먼저 운행하는 식으로 시작한 피실험자의 경우, 여러 대를 제어하는 시스템으로 리팩토링하는 단계에서 시간을 너무 소모하여 시간 내에 문제를 다 풀지 못하는 경우가 속출하였습니다.</p>\n\n<h2 id=\"승객-트래픽-모델링\">승객 트래픽 모델링</h2>\n\n<p>엘리베이터 요청은 크게 3가지로 분류할 수 있습니다. (빌딩의 입구는 1층이라고 가정) (참고: https://beta.vu.nl/nl/Images/werkstuk-boer_tcm235-91327.pdf)</p>\n\n<ul>\n  <li>incoming: 1층에서 특정 층으로 이동하는 요청</li>\n  <li>outgoing: 특정 층에서 1층으로 이동하는 요청</li>\n  <li>inter-floor: 1층을 제외한 층간 이동</li>\n</ul>\n\n<p>이번 테스트에서는 총 3개의 빌딩을 제시했습니다.</p>\n\n<p>첫 번째 어피치 맨션의 경우 5층 높이의 작은 맨션이고 총 요청은 6개입니다. 쉬운 문제를 통해 엘리베이터 시스템에 익숙해지고 API 연동을 해보는 몸풀기 문제라 할 수 있습니다.</p>\n\n<p>두 번째 제이지 빌딩은 25층 건물에 요청은 200개입니다. 위의 3가지 타입의 요청이 적절히 섞여 있는 가장 일반적인 형태의 모델이라고 할 수 있습니다.</p>\n\n<p>세 번째 라이언 타워는 25층 건물에 요청은 500개입니다. 라이언 타워는 승객의 패턴을 제공하고, 이에 맞는 효율적인 엘리베이터 분배 알고리즘을 구현하도록 유도한 문제입니다. 입구는 1층이고, 2층-12층은 개별 회사에 임대를 하고, 13층-25층은 카카오가 사용합니다. 따라서 2층-12층 내에서는 층간 이동이 거의 없는 반면, 13층-25층 사이에서는 층간 이동이 빈번합니다. 또한 13층에 카카오프렌즈샵이 위치하여 1층과 13층을 오가는 고객들이 많다는 상황을 설정하였습니다.</p>\n\n<h2 id=\"다양한-접근방법\">다양한 접근방법</h2>\n\n<h3 id=\"fifo\">FIFO</h3>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/fifo.gif\" alt=\"FIFO\" /></p>\n\n<p>가장 쉬운 접근법입니다. 요청이 들어온 순서대로 태우고 목적지에 내려준 후 다음 요청을 처리하는 형태입니다. 어피치 맨션의 경우 이 접근으로도 쉽게 풀립니다만, 제이지 빌딩, 라이언 타워의 경우 각각 약 4000, 13000 timestamp로 좋은 점수를 받을 수 없습니다.</p>\n\n<h3 id=\"collective-control\">Collective control</h3>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/look.gif\" alt=\"LOOK\" /></p>\n\n<p>위에서 설명한 collective control 알고리즘입니다. 가장 친숙한 동작 방식입니다. 1대만 사용했음에도 불구하고 제이지 빌딩에서 972의 timestamp를 기록할 정도로 효율적입니다. 라이언 타워의 경우 약 2000 timestamp를 기록할 수 있습니다.</p>\n\n<h3 id=\"다양한-전략들\">다양한 전략들</h3>\n\n<p>이번 문제의 엘리베이터는 보통의 엘리베이터와 다른 점이 있습니다. 이 부분을 활용하면 고득점을 할 수 있는데요. 출제진도 예상하지 못한 다양한 접근 방법들이 나와 놀랐습니다. 어떤 것들이 있는지 살펴보겠습니다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/idea0.gif\" alt=\"idea\" /></p>\n\n<p>0번 엘리베이터를 주목해주세요. 3명의 승객을 태우고 올라가던 엘리베이터는 17층에서 승객 1명을 내려주고 내려가는 방향의 승객 2명을 태워 올라갑니다. 일반적인 알고리즘과는 다른 방식인데요. 힌트는 평가 방법에 있습니다. 평가 조건은 모든 승객을 목적 층으로 수송해야 하며 가장 마지막 승객이 목적 층에 하차하였을 때의 시간 기준으로 평가를 합니다. 따라서 엘리베이터 내에 공간이 충분하다면 문이 열린 김에 태워가는 것이, 방향 전환 후 다시 멈추고, 문을 열고, 탑승시키는 것보다 효율적입니다.</p>\n\n<p>마찬가지로 승객의 요청이 들어왔을 때 바로 요청을 처리하지 않고 대기하는 지원자도 있었습니다. 승객을 태우기 위해 멈추고, 문을 열고, 닫고, 태우는 것이 모두 timestamp를 잡아먹기 때문에 충분히 기다렸다가 한꺼번에 태우는 것입니다. 또한 대기 중인 승객의 수에 따라 엘리베이터 이동 전략을 달리한 지원자도 있었습니다.</p>\n\n<p>그리고 결정적으로 현실의 엘리베이터와 차이가 나는 부분이 있습니다. 바로 요청을 받을 때 목적 층을 사전에 알 수 있다는 것입니다. 이 정보를 토대로 엘리베이터에 승객을 가고자 하는 층별로 그룹화하여 탑승시킬 수 있습니다. 심지어 엘리베이터를 움직이기 전에 모든 승객의 요청을 다 수집한 후에 움직이기 시작한 지원자도 있었습니다.</p>\n\n<h2 id=\"통계\">통계</h2>\n\n<h3 id=\"언어별-통계\">언어별 통계</h3>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/lang.png\" alt=\"LANGUAGE\" /></p>\n\n<p>Python이 압도적으로 높은 비율을 보였고 그 뒤를 Java와 Node가 뒤이었습니다.</p>\n\n<h3 id=\"시간대별-누적-성공-응시자-통계\">시간대별 누적 성공 응시자 통계</h3>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/time.png\" alt=\"TIMETABLE\" /></p>\n\n<p>빌딩별 가장 먼저 성공한 시각은 14시 12분 / 14시 40분 / 14시 53분입니다. 어피치 맨션을 2시간 30분 이내에 풀어야 남은 두 빌딩을 최적화하여 고득점 할 수 있을 것이라 예상하였는데, 예상외로 후반부의 집중력이 놀라웠습니다.</p>\n\n<h3 id=\"빌딩별-시도성공-비율\">빌딩별 시도/성공 비율</h3>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round2/building.png\" alt=\"BUILDING\" /></p>\n\n<h2 id=\"기타\">기타</h2>\n\n<p>2차 오프라인 코딩테스트에서 사용한 엘리베이터 시뮬레이션 서버는 직접 돌려볼 수 있도록 수정하여 공개하였습니다. <a href=\"https://github.com/kakao-recruit/2019-blind-2nd-elevator\">이 곳</a>에서 내려받아 실행할 수 있습니다.</p>\n\n<h2 id=\"마치며\">마치며</h2>\n\n<p>긴 시간 동안 문제 푸시느라 고생하셨습니다! 당락을 떠나 즐겁고 유익한 문제였기를 바랍니다</p>\n\n<h2 id=\"만든-사람들\">만든 사람들</h2>\n\n<ul>\n  <li>김동주 jude.traveller@kakaocorp(dot)com</li>\n  <li>송신형 lucid.s@kakaocorp(dot)com</li>\n  <li>안건 kyen.a@kakaocorp(dot)com</li>\n  <li>유승원 cree.yoo@kakaocorp(dot)com</li>\n  <li>이진환 root.lee@kakaocorp(dot)com</li>\n  <li>하광성 jesse.ha@kakaocorp(dot)com</li>\n</ul>\n\n<h2 id=\"문의\">문의</h2>\n\n<ul>\n  <li>하광성 jesse.ha@kakaocorp(dot)com</li>\n</ul>\n"
    } ,
  
    {
      "title"    : "if kakao 2018 동영상을 공개합니다.",
      "category" : "",
      "tags"     : "conference",
      "url"      : "/2018/10/17/if-kakao-dev-2018/",
      "date"     : "2018-10-17 17:00:00 +0900",
      "content"   : "<p>지난 9월 4일, 코엑스 그랜드볼룸에서 카카오의 개발자 콘퍼런스인 if kakao 2018이 성황리에 마쳤습니다.</p>\n\n<p>카카오 이름을 건 첫 번째 개발자 콘퍼런스인 if kakao 2018은 인공지능, 메신저, 택시, 결제/송금, 검색 등 수많은 영역에서 쌓은 카카오의 기술과 노하우를 외부에 공유하고 소통하는 자리였구요.</p>\n\n<p>신정환 CTO와 김병학 AI Lab 총괄 부사장의 기조연설과 인공지능, 머신러닝, 멀티미디어 처리, 챗봇, 클라우드, 오픈소스, 추천 등 다양한 주제의 27개 강연 세션을 진행했으며, 카카오의 서비스를 만드는 현직 개발자들이 실제 개발 사례를 중심으로 기술과 노하우를 생생하게 전달하려고 노력했습니다.</p>\n\n<p>이번 행사의 스케치 영상을 포함해 기조연설과 모든 강연 세션 <a href=\"https://tv.kakao.com/channel/3150758/cliplink/390279232?playlistId=209907&amp;metaObjectType=Playlist\">동영상</a>을 공개합니다.</p>\n\n<h2 id=\"행사-스케치-영상\">행사 스케치 영상</h2>\n\n<div style=\"width:640px; margin:1em auto;\"><iframe width=\"640\" height=\"360\" src=\"https://play-tv.kakao.com/embed/player/cliplink/390279232?service=kakao_tv\" allowfullscreen=\"\" frameborder=\"0\" scrolling=\"no\" allow=\"autoplay\"></iframe></div>\n\n<h2 id=\"카카오tv--︎\"><a href=\"https://tv.kakao.com/channel/3150758/cliplink/390279232?playlistId=209907&amp;metaObjectType=Playlist\">카카오TV  ▶︎</a></h2>\n\n<p>if kakao 2018 콘퍼런스의 모든 영상은 <strong>카카오TV의 <a href=\"https://tv.kakao.com/channel/3150758/cliplink/390279232?playlistId=209907&amp;metaObjectType=Playlist\">if kakao dev 2018 채널</a></strong>에서 확인할 수 있습니다. 아쉽게도 행사에 참석하지 못한 분들 뿐만 아니라, 행사에 참석했던 분들에게도 세션 내용을 다시 확인하는데 도움이 되었으면 합니다.</p>\n\n<p><img src=\"/files/if-kakaotv.png\" alt=\"카카오TV 'if kakao dev 2018' 채널\" /></p>\n\n<p>내년에는 더욱 멋진 콘퍼런스를 준비해서 찾아뵙겠습니다. 감사합니다.</p>\n"
    } ,
  
    {
      "title"    : "2019 카카오 신입 공채 1차 코딩 테스트 문제 해설",
      "category" : "",
      "tags"     : "blind-recruitment and coding",
      "url"      : "/2018/09/21/kakao-blind-recruitment-for2019-round-1/",
      "date"     : "2018-09-21 11:00:00 +0900",
      "content"   : "<p>작년에 이어 올해도 블라인드 전형으로 카카오 개발 신입 공채가 시작되었습니다!</p>\n\n<p>그 첫 번째 관문으로 1차 온라인 코딩 테스트가 지난 9월 15일(토) 오후 2시부터 7시까지 5시간 동안 치러졌는데요.</p>\n\n<p>지원자분들 만큼이나 준비위원들도 테스트가 문제없이, 공정하게 치러질 수 있도록 많은 준비를 했고 두근 거리는 마음으로 끝까지 온라인 테스트를 모니터링했답니다.</p>\n\n<p>문제는 작년과 비슷하게 구현 문제 위주로 쉬운 난이도에서 어려운 난이도 순으로 풀 수 있도록 차례대로 배치했고, 모든 테스트 케이스가 통과해야 문제를 풀이한 것으로 인정되도록 했습니다.\n단, 작년과는 다르게 효율성 테스트를 도입하여 같은 문제라도 입력의 크기에 따라 효율적인 풀이를 구현하도록 유도했고, 효율성 테스트가 있는 문제에서는 부분점수가 부여되도록 설계했습니다.</p>\n\n<p>그럼, 지금부터 문제 설명과 풀이를 살펴보도록 하겠습니다.</p>\n\n<h1 id=\"문제-설명\">문제 설명</h1>\n\n<h2 id=\"1-오픈채팅방\">1. 오픈채팅방</h2>\n\n<ul>\n  <li>정답률: 59.91%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42888\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.</p>\n\n<p>신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.</p>\n\n<p>“[닉네임]님이 들어왔습니다.”</p>\n\n<p>채팅방에서 누군가 나가면 다음 메시지가 출력된다.</p>\n\n<p>“[닉네임]님이 나갔습니다.”</p>\n\n<p>채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.</p>\n\n<ul>\n  <li>채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.</li>\n  <li>채팅방에서 닉네임을 변경한다.</li>\n</ul>\n\n<p>닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.</p>\n\n<p>예를 들어, 채팅방에 “Muzi”와 “Prodo”라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.</p>\n\n<p>“Muzi님이 들어왔습니다.”\n“Prodo님이 들어왔습니다.”</p>\n\n<p>채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.</p>\n\n<p>“Muzi님이 들어왔습니다.”\n“Prodo님이 들어왔습니다.”\n“Muzi님이 나갔습니다.”</p>\n\n<p>Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.</p>\n\n<p>“Prodo님이 들어왔습니다.”\n“Prodo님이 들어왔습니다.”\n“Prodo님이 나갔습니다.”\n“Prodo님이 들어왔습니다.”</p>\n\n<p>채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.</p>\n\n<p>“Prodo님이 들어왔습니다.”\n“Ryan님이 들어왔습니다.”\n“Prodo님이 나갔습니다.”\n“Prodo님이 들어왔습니다.”</p>\n\n<p>채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.</p>\n\n<h5 id=\"제한사항\">제한사항</h5>\n\n<ul>\n  <li>record는 다음과 같은 문자열이 담긴 배열이며, 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">100,000</code> 이하이다.</li>\n  <li>다음은 record에 담긴 문자열에 대한 설명이다.\n    <ul>\n      <li>모든 유저는 [유저 아이디]로 구분한다.</li>\n      <li>[유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - “Enter [유저 아이디] [닉네임]” (ex. “Enter uid1234 Muzi”)</li>\n      <li>[유저 아이디] 사용자가 채팅방에서 퇴장 - “Leave [유저 아이디]” (ex. “Leave uid1234”)</li>\n      <li>[유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - “Change [유저 아이디] [닉네임]” (ex. “Change uid1234 Muzi”)</li>\n      <li>첫 단어는 Enter, Leave, Change 중 하나이다.</li>\n      <li>각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.</li>\n      <li>유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.</li>\n      <li>유저 아이디와 닉네임의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">10</code> 이하이다.</li>\n      <li>채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h5 id=\"입출력-예\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>record</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[“Enter uid1234 Muzi”, “Enter uid4567 Prodo”,”Leave uid1234”,”Enter uid1234 Prodo”,”Change uid4567 Ryan”]</td>\n      <td>[“Prodo님이 들어왔습니다.”, “Ryan님이 들어왔습니다.”, “Prodo님이 나갔습니다.”, “Prodo님이 들어왔습니다.”]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명\">입출력 예 설명</h5>\n\n<p>입출력 예 #1\n문제의 설명과 같다.</p>\n\n<h3 id=\"문제-풀이\">문제 풀이</h3>\n<blockquote>\n  <p>첫 번째 문제답게 큰 고민 없이 연관 배열(맵)을 이용해서 쉽게 풀 수 있습니다.</p>\n\n  <p>record 를 순회 하면서</p>\n  <ul>\n    <li>Enter, Leave 인 경우 유저 아이디와 함께 정답에 출력될 메시지의 종류를 기록을 해둡니다. 이렇게 기록해둔 것을 <code class=\"highlighter-rouge\">events</code> 라고 합시다.</li>\n    <li>Enter, Change 인 경우 연관 배열을 이용하여 각 유저 아이디를 키로, 닉네임을 값으로 저장해 둡니다. 이렇게 해서 최종 닉네임을 유저 아이디별로 유지합니다.</li>\n  </ul>\n\n  <p>이제 <code class=\"highlighter-rouge\">events</code> 를 순회하면서 채팅방에 출력할 메시지를 생성할 때, 연관 배열에 저장된 아이디별 최종 닉네임을 이용하면 됩니다.</p>\n</blockquote>\n\n<h2 id=\"2-실패율\">2. 실패율</h2>\n\n<ul>\n  <li>정답률: 55.57%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42889\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/failure_rate.jpg\" /></p>\n\n<p>슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.</p>\n\n<p>이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.</p>\n\n<ul>\n  <li>실패율은 다음과 같이 정의한다.\n    <ul>\n      <li>스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수</li>\n    </ul>\n  </li>\n</ul>\n\n<p>전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.</p>\n\n<h5 id=\"제한사항-1\">제한사항</h5>\n\n<ul>\n  <li>스테이지의 개수 N은 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">500</code> 이하의 자연수이다.</li>\n  <li>stages의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">200,000</code> 이하이다.</li>\n  <li>stages에는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">N + 1</code> 이하의 자연수가 담겨있다.\n    <ul>\n      <li>각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.</li>\n      <li>단, <code class=\"highlighter-rouge\">N + 1</code> 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.</li>\n    </ul>\n  </li>\n  <li>만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.</li>\n  <li>스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 <code class=\"highlighter-rouge\">0</code> 으로 정의한다.</li>\n</ul>\n\n<h5 id=\"입출력-예-1\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>N</th>\n      <th>stages</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>[2, 1, 2, 6, 2, 4, 3, 3]</td>\n      <td>[3,4,2,1,5]</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>[4,4,4,4,4]</td>\n      <td>[4,1,2,3]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명-1\">입출력 예 설명</h5>\n\n<p>입출력 예 #1</p>\n\n<p>1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.</p>\n\n<ul>\n  <li>1번 스테이지 실패율 : 1/8</li>\n</ul>\n\n<p>2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.</p>\n\n<ul>\n  <li>2번 스테이지 실패율 : 3/7</li>\n</ul>\n\n<p>마찬가지로 나머지 스테이지의 실패율은 다음과 같다.</p>\n\n<ul>\n  <li>3번 스테이지 실패율 : 2/4</li>\n  <li>4번 스테이지 실패율 : 1/2</li>\n  <li>5번 스테이지 실패율 : 0/1</li>\n</ul>\n\n<p>각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.</p>\n\n<ul>\n  <li>[3,4,2,1,5]</li>\n</ul>\n\n<p>입출력 예 #2</p>\n\n<p>모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.</p>\n\n<ul>\n  <li>[4,1,2,3]</li>\n</ul>\n\n<h3 id=\"문제-풀이-1\">문제 풀이</h3>\n<blockquote>\n  <p>문제를 읽어보면 알 수 있듯이 이 문제는 정렬을 이용해서 풀 수 있습니다.</p>\n\n  <p>먼저 주어진 배열의 길이를 이용하여 전체 사용자 수를 구하고, <code class=\"highlighter-rouge\">stages</code> 를 순회하며 각 스테이지에 몇 명의 사용자가 도달했는지 세줍니다. \n이렇게 만들어둔 배열(각 스테이지별 사용자 수가 들어있는)을 순회하면서 <code class=\"highlighter-rouge\">stages</code> 를 참고하여 스테이지별 실패율을 계산합니다. \n이때, 스테이지에 도달한 사용자가 0명인 경우 예외 처리를 해야 합니다. 스테이지별 실패율을 구했다면, 각 스테이지 번호와 묶어서 실패율 내림차순으로 정렬합니다. \n실패율이 같은 경우는 스테이지 번호가 작은 것을 먼저 오도록 정렬하면 됩니다.</p>\n</blockquote>\n\n<h2 id=\"3-후보키\">3. 후보키</h2>\n\n<ul>\n  <li>정답률: 16.09%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42890\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다.</p>\n\n<p>그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다.</p>\n\n<p>후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다.</p>\n\n<ul>\n  <li>관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.\n    <ul>\n      <li>유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.</li>\n      <li>최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/cand_key.jpg\" /></p>\n\n<p>위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 “학번”을 가지고 있다. 따라서 “학번”은 릴레이션의 후보 키가 될 수 있다.\n그다음 “이름”에 대해서는 같은 이름(“apeach”)을 사용하는 학생이 있기 때문에, “이름”은 후보 키가 될 수 없다. 그러나, 만약 [“이름”, “전공”]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다.\n물론 [“이름”, “전공”, “학년”]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다.\n따라서, 위의 학생 인적사항의 후보키는 “학번”, [“이름”, “전공”] 두 개가 된다.</p>\n\n<p>릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라.</p>\n\n<h5 id=\"제한사항-2\">제한사항</h5>\n\n<ul>\n  <li>relation은 2차원 문자열 배열이다.</li>\n  <li>relation의 컬럼(column)의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">8</code> 이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다.</li>\n  <li>relation의 로우(row)의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">20</code> 이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다.</li>\n  <li>relation의 모든 문자열의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">8</code> 이하이며, 알파벳 소문자와 숫자로만 이루어져 있다.</li>\n  <li>relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.)</li>\n</ul>\n\n<h5 id=\"입출력-예-2\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>relation</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[[“100”,”ryan”,”music”,”2”],[“200”,”apeach”,”math”,”2”],[“300”,”tube”,”computer”,”3”],[“400”,”con”,”computer”,”4”],[“500”,”muzi”,”music”,”3”],[“600”,”apeach”,”music”,”2”]]</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명-2\">입출력 예 설명</h5>\n\n<p>입출력 예 #1\n문제에 주어진 릴레이션과 같으며, 후보 키는 2개이다.</p>\n\n<h3 id=\"문제-풀이-2\">문제 풀이</h3>\n<blockquote>\n  <p>가능한 모든 어트리뷰트의 조합을 만들고, 이 조합에서 조건을 만족시키는 조합만 추려야 하는 문제입니다.</p>\n\n  <p>dfs 또는 bit 를 이용한 집합 표현을 이용하여 어트리뷰트의 모든 부분 집합을 만들어냅니다.<br />\n만들어지는 각 부분 집합을 이용해서 중복 튜플이 있는지 검사합니다. \n만약 중복 튜플이 없다면, 이 부분 집합을 슈퍼 키 집합(유일성을 만족하는 키들의 집합)에 포함시킵니다.</p>\n\n  <p>슈퍼 키 집합을 구한 후, 여기서 최소성을 만족하는 키들을 선택하여 후보 키 집합을 만들 수 있습니다.<br />\n만약 어떤 슈퍼 키 X에 대해 X의 부분집합인 슈퍼 키 Y가 없다면 (X ⊃ Y인 슈퍼 키 Y가 없다면) X는 후보 키로 선택될 수 있습니다.</p>\n\n  <p>예를 들어 어떤 릴레이션의 어트리뷰트가 ABCDE 이고, 슈퍼 키 집합이 {A, AB, BC, BCE, BDE, …} 라고 해봅시다.</p>\n\n  <ul>\n    <li>A 는 후보 키로 선택될 수 있습니다.</li>\n    <li>AB 는 AB ⊃ A 이므로 후보 키가 될 수 없습니다.</li>\n    <li>BC 는 부분집합이 되는 다른 슈퍼 키가 없으므로 후보 키로 선택됩니다.</li>\n    <li>BCE 는 BCE ⊃ BC 이므로 후보 키가 될 수 없습니다.</li>\n    <li>BDE 는 부분집합이 되는 다른 슈퍼 키가 없으므로 후보 키로 선택됩니다.</li>\n    <li>…</li>\n  </ul>\n\n  <p>따라서 이 경우 후보 키 집합은 {A, BC, BDE, …} 가 됩니다.</p>\n\n  <p>가능한 모든 조합을 만드는 부분 때문인지 앞쪽에 배치된 문제임에도 많은 지원자들이 어려움을 겪은 것으로 보입니다.</p>\n</blockquote>\n\n<h2 id=\"4-무지의-먹방-라이브\">4. 무지의 먹방 라이브</h2>\n\n<ul>\n  <li>정답률: 정확성 42.08% / 효율성 5.52%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42891\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p><code class=\"highlighter-rouge\">* 효율성 테스트에 부분 점수가 있는 문제입니다.</code></p>\n\n<p>평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/muji_live.jpg\" /></p>\n\n<p>그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.</p>\n\n<p>회전판에 먹어야 할 N 개의 음식이 있다. \n각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다. \n무지는 다음과 같은 방법으로 음식을 섭취한다.</p>\n\n<ul>\n  <li>무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.</li>\n  <li>마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.</li>\n  <li>무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.\n    <ul>\n      <li>다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.</li>\n    </ul>\n  </li>\n  <li>회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.</li>\n</ul>\n\n<p>무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.\n무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다. \n각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.</p>\n\n<h5 id=\"제한사항-3\">제한사항</h5>\n\n<ul>\n  <li>food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.</li>\n  <li>k 는 방송이 중단된 시간을 나타낸다.</li>\n  <li>만약 더 섭취해야 할 음식이 없다면 <code class=\"highlighter-rouge\">-1</code>을 반환하면 된다.</li>\n</ul>\n\n<h5 id=\"정확성-테스트-제한-사항\">정확성 테스트 제한 사항</h5>\n\n<ul>\n  <li>food_times 의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">2,000</code> 이하이다.</li>\n  <li>food_times 의 원소는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">1,000</code> 이하의 자연수이다.</li>\n  <li>k는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">2,000,000</code> 이하의 자연수이다.</li>\n</ul>\n\n<h5 id=\"효율성-테스트-제한-사항\">효율성 테스트 제한 사항</h5>\n\n<ul>\n  <li>food_times 의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">200,000</code> 이하이다.</li>\n  <li>food_times 의 원소는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">100,000,000</code> 이하의 자연수이다.</li>\n  <li>k는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">2 x  10^13</code> 이하의 자연수이다.</li>\n</ul>\n\n<h5 id=\"입출력-예-3\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>food_times</th>\n      <th>k</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[3, 1, 2]</td>\n      <td>5</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명-3\">입출력 예 설명</h5>\n\n<p>입출력 예 #1</p>\n<ul>\n  <li>0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.</li>\n  <li>1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.</li>\n  <li>2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.</li>\n  <li>3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.</li>\n  <li>4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.</li>\n  <li>5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.</li>\n</ul>\n\n<h3 id=\"문제-풀이-3\">문제 풀이</h3>\n<blockquote>\n  <p>이 문제를 완전히 해결하려면 효율성 테스트를 통과해야 합니다.<br />\n효율성 테스트의 제한 사항은 정확성 테스트보다 까다롭기 때문에 정확성 테스트를 통과한 풀이를 그대로 적용하면 시간 초과가 발생합니다.\n따라서, 실행 시간을 줄일 수 있는 아이디어가 필요합니다.</p>\n\n  <h5 id=\"정확성-풀이\">정확성 풀이</h5>\n  <p>시간이 1초 지날 때마다 다음 먹을 음식을 반복문을 이용해 하나하나 찾아가며 시뮬레이션하면 됩니다.</p>\n\n  <h5 id=\"효율성-풀이\">효율성 풀이</h5>\n  <p>먼저 음식별 필요 시간을 오름차순으로 정렬합니다. 시간의 오름차순으로 정렬해두면 음식을 먹는 데 소요되는 시간을 한꺼번에 지울 수 있습니다.\n예를 들어 정렬한 시간이 T = [1, 3, 3, 4, 5]라면 처음에 T[0] * 5 = 5만큼의 시간을 한꺼번에 지울 수 있습니다. 다음으로 T[1]부터 남은 시간을 한꺼번에 제거합니다. \n즉, (T[1] - T[0]) * 4 = 8 만큼의 시간을 한꺼번에 지웁니다. 마찬가지로 (T[2] - T[1]) * 3 = 0 만큼의 시간을 한꺼번에 지울 수 있습니다.</p>\n\n  <p>위와 같은 방법으로 시간을 지워가다가, 지운 시간의 합이 K 보다 커지게 되면 남은 시간의 개수로 나눈 나머지를 이용해 K 초 후 다시 먹기 시작해야 될 음식의 번호를 바로 구할 수 있습니다. \n이때, 남은 시간을 다시 원래 음식의 번호 순서대로 재정렬해야 합니다.</p>\n\n  <p>꼭 이 방법이 아니라도 K에 도달하는 시점을 빠르게 구할 수만 있으면 실행 시간을 줄일 수 있습니다.</p>\n</blockquote>\n\n<h2 id=\"5-길-찾기-게임\">5. 길 찾기 게임</h2>\n\n<ul>\n  <li>정답률: 7.40%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42892\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다. \n내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.</p>\n\n<p>라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다.</p>\n\n<p>그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.</p>\n\n<p>라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다.</p>\n\n<ul>\n  <li>트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다.</li>\n  <li>모든 노드는 서로 다른 x값을 가진다.</li>\n  <li>같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다.</li>\n  <li>자식 노드의 y 값은 항상 부모 노드보다 작다.</li>\n  <li>임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다.</li>\n  <li>임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.</li>\n</ul>\n\n<p>아래 예시를 확인해보자.</p>\n\n<p>라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/tree_1.jpg\" /></p>\n\n<p>이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/tree_2.jpg\" /></p>\n\n<p>위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다.</p>\n\n<ul>\n  <li>전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3</li>\n  <li>후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7</li>\n</ul>\n\n<p>다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다.<br />\n그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.</p>\n\n<p>이제 당신이 나설 때가 되었다.</p>\n\n<p>곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때, \n노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.</p>\n\n<h5 id=\"제한사항-4\">제한사항</h5>\n\n<ul>\n  <li>nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다.\n    <ul>\n      <li>nodeinfo의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">10,000</code> 이하이다.</li>\n      <li>nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다.</li>\n      <li>모든 노드의 좌표 값은 <code class=\"highlighter-rouge\">0</code> 이상 <code class=\"highlighter-rouge\">100,000</code> 이하인 정수이다.</li>\n      <li>트리의 깊이가 <code class=\"highlighter-rouge\">1,000</code> 이하인 경우만 입력으로 주어진다.</li>\n      <li>모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h5 id=\"입출력-예-4\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>nodeinfo</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]]</td>\n      <td>[[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명-4\">입출력 예 설명</h5>\n\n<p>입출력 예 #1</p>\n\n<p>문제에 주어진 예시와 같다.</p>\n\n<h3 id=\"문제-풀이-4\">문제 풀이</h3>\n<blockquote>\n  <p>트리를 순회하는 방법은 검색을 통해 쉽게 알 수 있으므로 문제가 되지 않습니다. 이 문제의 핵심은 좌표 값으로 주어지는 노드들을 트리로 구성하는 부분입니다.</p>\n\n  <p>트리를 만들기 위해 y 값을 이용해서 각 노드의 level 을 분리하고, 현재 노드의 자식 노드가 가질 수 있는 x값을 이용하여 현재 노드의 왼쪽, 오른쪽 자식을 정확히 찾는 것이 중요합니다.</p>\n\n  <p>각 노드의 왼쪽, 오른쪽 자식 노드는 다음과 같이 찾을 수 있습니다.</p>\n\n  <p>먼저 현재 노드 P의 x값을 Px, 현재 노드의 자식 노드가 가질 수 있는 x 범위를 Lx, Rx (Lx &lt; Px &lt; Rx)라고 하겠습니다. 또 어떤 노드 K의 x값을 Kx 라고 하겠습니다.\n만약 현재 노드의 바로 다음 레벨에 Lx ≤ Kx &lt; Px를 만족하는 노드 K가 있다면 K는 노드 P의 왼쪽 자식이 됩니다. 이때, 노드 K의 자식 노드가 가질 수 있는 x값의 범위는 Lx ≤ x ≤ Px - 1 (x ≠ Kx)가 됩니다.</p>\n\n  <p>마찬가지로 현재 노드의 바로 다음 레벨에 Px &lt; Kx ≤ Rx를 만족하는 노드 K가 있다면 K는 노드 P의 오른쪽 자식이 되며, 노드 K의 자식 노드가 가질 수 있는 x의 범위는 Px + 1 ≤ x ≤ Rx (x ≠ Kx)가 됩니다.</p>\n\n  <p>위 과정을 재귀적으로 반복하면서 각 노드의 왼쪽, 오른쪽 자식을 찾아주면 트리를 구성할 수 있습니다.</p>\n\n  <p>노드별 왼쪽, 오른쪽 자식을 찾는 방법은 여러 가지가 있을 수 있습니다. \n그중 하나로, 재귀적으로 순회하며 트리를 만들면 같은 level의 노드는 x값이 작은 노드부터 방문하게 되므로, \n큐를 트리의 레벨만큼 만들어 두고, x축 기준으로 오름차순 정렬된 노드들을 y축 값이 같은 노드끼리 각 큐에 넣어두면 큐의 front를 확인하는 방법으로 O(1)에 찾을 수 있습니다.</p>\n\n  <p>이렇게 하면 노드의 수가 N일 때, 트리를 구성하는 데는 O(N) 시간이 소요되며, 시간 복잡도는 전체 노드를 정렬하는데 걸리는 시간인 O(NlogN)이 됩니다.</p>\n</blockquote>\n\n<h2 id=\"6-매칭-점수\">6. 매칭 점수</h2>\n\n<ul>\n  <li>정답률: 6.12%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42893\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>프렌즈 대학교 조교였던 제이지는 허드렛일만 시키는 네오 학과장님의 마수에서 벗어나, 카카오에 입사하게 되었다. \n평소에 관심있어하던 검색에 마침 결원이 발생하여, 검색개발팀에 편입될 수 있었고, 대망의 첫 프로젝트를 맡게 되었다.\n그 프로젝트는 검색어에 가장 잘 맞는 웹페이지를 보여주기 위해 아래와 같은 규칙으로 검색어에 대한 웹페이지의 매칭점수를 계산 하는 것이었다.</p>\n\n<ul>\n  <li>한 웹페이지에 대해서 기본점수, 외부 링크 수, 링크점수, 그리고 매칭점수를 구할 수 있다.</li>\n  <li>한 웹페이지의 기본점수는 해당 웹페이지의 텍스트 중, 검색어가 등장하는 횟수이다. (대소문자 무시)</li>\n  <li>한 웹페이지의 외부 링크 수는 해당 웹페이지에서 다른 외부 페이지로 연결된 링크의 개수이다.</li>\n  <li>한 웹페이지의 링크점수는 해당 웹페이지로 링크가 걸린 다른 웹페이지의 기본점수 ÷ 외부 링크 수의 총합이다.</li>\n  <li>한 웹페이지의 매칭점수는 기본점수와 링크점수의 합으로 계산한다.</li>\n</ul>\n\n<p>예를 들어, 다음과 같이 A, B, C 세 개의 웹페이지가 있고, 검색어가 hi라고 하자.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/page_rank.jpg\" /></p>\n\n<p>이때 A 웹페이지의 매칭점수는 다음과 같이 계산할 수 있다.</p>\n\n<ul>\n  <li>기본 점수는 각 웹페이지에서 hi가 등장한 횟수이다.\n    <ul>\n      <li>A,B,C 웹페이지의 기본점수는 각각 1점, 4점, 9점이다.</li>\n    </ul>\n  </li>\n  <li>외부 링크수는 다른 웹페이지로 링크가 걸린 개수이다.\n    <ul>\n      <li>A,B,C 웹페이지의 외부 링크 수는 각각 1점, 2점, 3점이다.</li>\n    </ul>\n  </li>\n  <li>A 웹페이지로 링크가 걸린 페이지는 B와 C가 있다.\n    <ul>\n      <li>A 웹페이지의 링크점수는 B의 링크점수 2점(4 ÷ 2)과 C의 링크점수 3점(9 ÷ 3)을 더한 5점이 된다.</li>\n    </ul>\n  </li>\n  <li>그러므로, A 웹페이지의 매칭점수는 기본점수 1점 + 링크점수 5점 = 6점이 된다.</li>\n</ul>\n\n<p>검색어 word와 웹페이지의 HTML 목록인 pages가 주어졌을 때, 매칭점수가 가장 높은 웹페이지의 index를 구하라. 만약 그런 웹페이지가 여러 개라면 그중 번호가 가장 작은 것을 구하라.</p>\n\n<h5 id=\"제한사항-5\">제한사항</h5>\n\n<ul>\n  <li>pages는 HTML 형식의 웹페이지가 문자열 형태로 들어있는 배열이고, 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">20</code> 이하이다.</li>\n  <li>한 웹페이지 문자열의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">1,500</code> 이하이다.</li>\n  <li>웹페이지의 index는 pages 배열의 index와 같으며 0부터 시작한다.</li>\n  <li>한 웹페이지의 url은 HTML의 &lt;head&gt; 태그 내에 &lt;meta&gt; 태그의 값으로 주어진다.\n    <ul>\n      <li>예를들어, 아래와 같은 meta tag가 있으면 이 웹페이지의 url은 https://careers.kakao.com/index 이다.</li>\n      <li>&lt;meta property=”og:url” content=”https://careers.kakao.com/index” /&gt;</li>\n    </ul>\n  </li>\n  <li>한 웹페이지에서 모든 외부 링크는 &lt;a href=”https://careers.kakao.com/index”&gt;의 형태를 가진다.\n    <ul>\n      <li>&lt;a&gt; 내에 다른 attribute가 주어지는 경우는 없으며 항상 href로 연결할 사이트의 url만 포함된다.</li>\n      <li>위의 경우에서 해당 웹페이지는 https://careers.kakao.com/index 로 외부링크를 가지고 있다고 볼 수 있다.</li>\n    </ul>\n  </li>\n  <li>모든 url은 https:// 로만 시작한다.</li>\n  <li>검색어 word는 하나의 영어 단어로만 주어지며 알파벳 소문자와 대문자로만 이루어져 있다.</li>\n  <li>word의 길이는 <code class=\"highlighter-rouge\">1</code> 이상 <code class=\"highlighter-rouge\">12</code> 이하이다.</li>\n  <li>검색어를 찾을 때, 대소문자 구분은 무시하고 찾는다.\n    <ul>\n      <li>예를들어 검색어가 blind일 때, HTML 내에 Blind라는 단어가 있거나, BLIND라는 단어가 있으면 두 경우 모두 해당된다.</li>\n    </ul>\n  </li>\n  <li>검색어는 단어 단위로 비교하며, 단어와 완전히 일치하는 경우에만 기본 점수에 반영한다.\n    <ul>\n      <li>단어는 알파벳을 제외한 다른 모든 문자로 구분한다.</li>\n      <li>예를들어 검색어가 “aba” 일 때, “abab abababa”는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다.</li>\n      <li>만약 검색어가 “aba” 라면, “aba@aba aba”는 단어 단위로 세개가 일치하므로, 기본 점수는 3점이다.</li>\n    </ul>\n  </li>\n  <li>결과를 돌려줄때, 동일한 매칭점수를 가진 웹페이지가 여러 개라면 그중 index 번호가 가장 작은 것를 리턴한다\n    <ul>\n      <li>즉, 웹페이지가 세개이고, 각각 매칭점수가 3,1,3 이라면 제일 적은 index 번호인 0을 리턴하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h5 id=\"입출력-예-1\">입출력 예 #1</h5>\n\n<ul>\n  <li>\n    <p>word : blind</p>\n  </li>\n  <li>pages :\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[\"<span class=\"nt\">&lt;html</span> <span class=\"na\">lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xml:lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xmlns=</span><span class=\"s\">\\\"http://www.w3.org/1999/xhtml\\\"</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;head&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">charset=</span><span class=\"s\">\\\"utf-8\\\"</span><span class=\"nt\">&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">property=</span><span class=\"s\">\\\"og:url\\\"</span> <span class=\"na\">content=</span><span class=\"s\">\\\"https://a.com\\\"/</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;/head&gt;</span>  \\n<span class=\"nt\">&lt;body&gt;</span>\\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \\n<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://b.com\\\"</span><span class=\"nt\">&gt;</span> Link to b <span class=\"nt\">&lt;/a&gt;</span>\\n<span class=\"nt\">&lt;/body&gt;</span>\\n<span class=\"nt\">&lt;/html&gt;</span>\", \"<span class=\"nt\">&lt;html</span> <span class=\"na\">lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xml:lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xmlns=</span><span class=\"s\">\\\"http://www.w3.org/1999/xhtml\\\"</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;head&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">charset=</span><span class=\"s\">\\\"utf-8\\\"</span><span class=\"nt\">&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">property=</span><span class=\"s\">\\\"og:url\\\"</span> <span class=\"na\">content=</span><span class=\"s\">\\\"https://b.com\\\"/</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;/head&gt;</span>  \\n<span class=\"nt\">&lt;body&gt;</span>\\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \\n<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://a.com\\\"</span><span class=\"nt\">&gt;</span> Link to a <span class=\"nt\">&lt;/a&gt;</span>\\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\\n<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://c.com\\\"</span><span class=\"nt\">&gt;</span> Link to c <span class=\"nt\">&lt;/a&gt;</span>\\n<span class=\"nt\">&lt;/body&gt;</span>\\n<span class=\"nt\">&lt;/html&gt;</span>\", \"<span class=\"nt\">&lt;html</span> <span class=\"na\">lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xml:lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xmlns=</span><span class=\"s\">\\\"http://www.w3.org/1999/xhtml\\\"</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;head&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">charset=</span><span class=\"s\">\\\"utf-8\\\"</span><span class=\"nt\">&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">property=</span><span class=\"s\">\\\"og:url\\\"</span> <span class=\"na\">content=</span><span class=\"s\">\\\"https://c.com\\\"/</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;/head&gt;</span>  \\n<span class=\"nt\">&lt;body&gt;</span>\\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\\n<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://a.com\\\"</span><span class=\"nt\">&gt;</span> Link to a <span class=\"nt\">&lt;/a&gt;</span>\\n<span class=\"nt\">&lt;/body&gt;</span>\\n<span class=\"nt\">&lt;/html&gt;</span>\"]\n</code></pre></div>    </div>\n  </li>\n  <li>pages는 다음과 같이 3개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다.</li>\n</ul>\n\n<pre><code class=\"language-HTML\">&lt;html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta property=\"og:url\" content=\"https://a.com\"/&gt;\n&lt;/head&gt;  \n&lt;body&gt;\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \n&lt;a href=\"https://b.com\"&gt; Link to b &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<pre><code class=\"language-HTML\">&lt;html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta property=\"og:url\" content=\"https://b.com\"/&gt;\n&lt;/head&gt;  \n&lt;body&gt;\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \n&lt;a href=\"https://a.com\"&gt; Link to a &lt;/a&gt;\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\n&lt;a href=\"https://c.com\"&gt; Link to c &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<pre><code class=\"language-HTML\">&lt;html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta property=\"og:url\" content=\"https://c.com\"/&gt;\n&lt;/head&gt;  \n&lt;body&gt;\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\n&lt;a href=\"https://a.com\"&gt; Link to a &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>위의 예를 가지고 각각의 점수를 계산해보자.</p>\n\n<ul>\n  <li>기본점수 및 외부 링크수는 아래와 같다.\n    <ul>\n      <li>a.com의 기본점수는 3, 외부 링크 수는 1개</li>\n      <li>b.com의 기본점수는 1, 외부 링크 수는 2개</li>\n      <li>c.com의 기본점수는 1, 외부 링크 수는 1개</li>\n    </ul>\n  </li>\n  <li>링크점수는 아래와 같다.\n    <ul>\n      <li>a.com의 링크점수는 b.com으로부터 0.5점, c.com으로부터 1점</li>\n      <li>b.com의 링크점수는 a.com으로부터 3점</li>\n      <li>c.com의 링크점수는 b.com으로부터 0.5점</li>\n    </ul>\n  </li>\n  <li>각 웹 페이지의 매칭 점수는 다음과 같다.\n    <ul>\n      <li>a.com : 4.5 점</li>\n      <li>b.com : 4 점</li>\n      <li>c.com : 1.5 점</li>\n    </ul>\n  </li>\n</ul>\n\n<p>따라서 매칭점수가 제일 높은 첫번째 웹 페이지의 index인 0을 리턴 하면 된다.</p>\n\n<h5 id=\"입출력-예-2\">입출력 예 #2</h5>\n\n<ul>\n  <li>\n    <p>word : Muzi</p>\n  </li>\n  <li>pages :\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[\"<span class=\"nt\">&lt;html</span> <span class=\"na\">lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xml:lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xmlns=</span><span class=\"s\">\\\"http://www.w3.org/1999/xhtml\\\"</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;head&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">charset=</span><span class=\"s\">\\\"utf-8\\\"</span><span class=\"nt\">&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">property=</span><span class=\"s\">\\\"og:url\\\"</span> <span class=\"na\">content=</span><span class=\"s\">\\\"https://careers.kakao.com/interview/list\\\"/</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;/head&gt;</span>  \\n<span class=\"nt\">&lt;body&gt;</span>\\n<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://programmers.co.kr/learn/courses/4673\\\"</span><span class=\"nt\">&gt;&lt;/a&gt;</span>#!MuziMuzi!)jayg07con<span class=\"err\">&amp;&amp;</span>\\n\\n<span class=\"nt\">&lt;/body&gt;</span>\\n<span class=\"nt\">&lt;/html&gt;</span>\", \"<span class=\"nt\">&lt;html</span> <span class=\"na\">lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xml:lang=</span><span class=\"s\">\\\"ko\\\"</span> <span class=\"na\">xmlns=</span><span class=\"s\">\\\"http://www.w3.org/1999/xhtml\\\"</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;head&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">charset=</span><span class=\"s\">\\\"utf-8\\\"</span><span class=\"nt\">&gt;</span>\\n  <span class=\"nt\">&lt;meta</span> <span class=\"na\">property=</span><span class=\"s\">\\\"og:url\\\"</span> <span class=\"na\">content=</span><span class=\"s\">\\\"https://www.kakaocorp.com\\\"/</span><span class=\"nt\">&gt;</span>\\n<span class=\"nt\">&lt;/head&gt;</span>  \\n<span class=\"nt\">&lt;body&gt;</span>\\ncon%\\tmuzI92apeach<span class=\"err\">&amp;</span>2<span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\\\"https://hashcode.co.kr/tos\\\"</span><span class=\"nt\">&gt;&lt;/a&gt;</span>\\n\\n\\t^\\n<span class=\"nt\">&lt;/body&gt;</span>\\n<span class=\"nt\">&lt;/html&gt;</span>\"]\n</code></pre></div>    </div>\n  </li>\n  <li>pages는 다음과 같이 2개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다.</li>\n</ul>\n\n<pre><code class=\"language-HTML\">&lt;html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta property=\"og:url\" content=\"https://careers.kakao.com/interview/list\"/&gt;\n&lt;/head&gt;  \n&lt;body&gt;\n&lt;a href=\"https://programmers.co.kr/learn/courses/4673\"&gt;&lt;/a&gt;#!MuziMuzi!)jayg07con&amp;&amp;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<pre><code class=\"language-HTML\">&lt;html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta property=\"og:url\" content=\"https://www.kakaocorp.com\"/&gt;\n&lt;/head&gt;  \n&lt;body&gt;\ncon%\tmuzI92apeach&amp;2&lt;a href=\"https://hashcode.co.kr/tos\"&gt;&lt;/a&gt;\n\n\t^\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<ul>\n  <li>\n    <p>기본점수 및 외부 링크수는 아래와 같다.</p>\n\n    <ul>\n      <li><code class=\"highlighter-rouge\">careers.kakao.com/interview/list</code> 의 기본점수는 0, 외부 링크 수는 1개</li>\n      <li><code class=\"highlighter-rouge\">www.kakaocorp.com</code> 의 기본점수는 1, 외부 링크 수는 1개</li>\n    </ul>\n  </li>\n  <li>\n    <p>링크점수는 아래와 같다.</p>\n\n    <ul>\n      <li><code class=\"highlighter-rouge\">careers.kakao.com/interview/list</code> 의 링크점수는 0점</li>\n      <li><code class=\"highlighter-rouge\">www.kakaocorp.com</code> 의 링크점수는 0점</li>\n    </ul>\n  </li>\n  <li>\n    <p>각 웹 페이지의 매칭 점수는 다음과 같다.</p>\n\n    <ul>\n      <li><code class=\"highlighter-rouge\">careers.kakao.com/interview/list</code> : 0점</li>\n      <li><code class=\"highlighter-rouge\">www.kakaocorp.com</code> : 1 점</li>\n    </ul>\n  </li>\n</ul>\n\n<p>따라서 매칭점수가 제일 높은 두번째 웹 페이지의 index인 1을 리턴 하면 된다.</p>\n\n<h3 id=\"문제-풀이-5\">문제 풀이</h3>\n<blockquote>\n  <p>점수를 계산하는 로직 자체는 복잡하지 않지만, 점수 계산에 필요한 요소들을 잘 추출해야 하는 문제입니다.</p>\n\n  <p>정규표현식을 이용하거나 문자열 처리 로직을 구현해서 a 태그와 meta 태그를 찾아 현재 페이지의 URL 과 외부 링크의 URL 을 찾습니다.\n또한, 전체 HTML 문서를 대상으로 검색어가 몇 번 등장하는지 찾습니다. 이때, 제시된 조건에 맞게 단어를 찾을 수 있도록 적절히 split 하여 비교합니다. \n각 HTML 문서별 기본 점수, 외부 링크 수를 구하고, 해당 웹페이지로 링크가 걸린 다른 웹페이지들을 찾아 링크 점수를 계산합니다.</p>\n\n  <p>마지막으로 각 페이지의 매칭 점수를 구하고, 최댓값을 갖는 문서의 인덱스를 구하면 됩니다.</p>\n</blockquote>\n\n<h2 id=\"7-블록-게임\">7. 블록 게임</h2>\n\n<ul>\n  <li>정답률: 5.85%</li>\n  <li><a href=\"https://www.welcomekakao.com/learn/courses/30/lessons/42894\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다.</p>\n\n<p>이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다.</p>\n\n<p>프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자.</p>\n\n<h5 id=\"게임규칙\">게임규칙</h5>\n\n<p>아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/blocks_1.jpg\" /></p>\n\n<p>1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다.</p>\n\n<p>플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다. \n이때, 검은 블록과 기존에 놓인 블록을 합해 <em><strong>속이 꽉 채워진</strong></em> 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다.</p>\n\n<p>예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/blocks_2.jpg\" /></p>\n\n<p>빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다.</p>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/blocks_3.jpg\" /></p>\n\n<p>그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다.</p>\n\n<p>따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다.</p>\n\n<p>보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라.</p>\n\n<h5 id=\"제한사항-6\">제한사항</h5>\n\n<ul>\n  <li>board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다.\n    <ul>\n      <li>N은 <code class=\"highlighter-rouge\">4</code> 이상 <code class=\"highlighter-rouge\">50</code> 이하다.</li>\n    </ul>\n  </li>\n  <li>board의 각 행의 원소는 <code class=\"highlighter-rouge\">0</code> 이상 <code class=\"highlighter-rouge\">200</code> 이하의 자연수이다.\n    <ul>\n      <li>0 은 빈 칸을 나타낸다.</li>\n      <li>board에 놓여있는 각 블록은 숫자를 이용해 표현한다.</li>\n      <li>잘못된 블록 모양이 주어지는 경우는 없다.</li>\n      <li>모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현됩니다.</li>\n      <li>예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"http://t1.kakaocdn.net/welcome/2019/round1/blocks_4.jpg\" /></p>\n\n<h5 id=\"입출력-예-5\">입출력 예</h5>\n\n<table>\n  <thead>\n    <tr>\n      <th>board</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]]</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n\n<h5 id=\"입출력-예-설명-5\">입출력 예 설명</h5>\n\n<p>입출력 예 #1\n문제에 주어진 예시와 같음</p>\n\n<h3 id=\"문제-풀이-6\">문제 풀이</h3>\n<blockquote>\n  <p>문제를 이해하는 것은 어렵지 않지만 제거해야 할 블록을 찾기 위한 아이디어가 필요합니다.</p>\n\n  <p>문제에서는 검은 블록을 떨어뜨린다고 되어있으나, 실제로 검은 블록을 떨어뜨리지 않고 순서대로 검은 블록으로 채워 나가기만 해도 삭제될 블록을 찾을 수 있습니다. \n먼저 게임 보드의 왼쪽 위(혹은 오른쪽 위)부터 가로 방향으로 한 줄씩 순서대로 진행하면서 빈칸에 검은 블록을 채울 수 있는지 확인합니다. 현재 칸이 빈칸이라면 위쪽으로 삭제되지 않은 블록이 있는지 확인합니다. \n만약 다른 블록이 없다면 검은 블록으로 채우고, 그렇지 않으면 그대로 빈칸으로 둡니다.</p>\n\n  <p>칸 하나를 확인한 후에는 해당 칸을 포함하는 칸 중에서 삭제할 수 있는 블록이 있는지 확인합니다. \n블록이 사라질 수 있는지 판단은 검은 블록 두 개와 같은 색 블록 4개가 2x3, 3x2의 직사각형 안에 들어있는지 확인하면 됩니다.</p>\n\n  <p>블록을 지운 경우에 지워진 칸을 그대로 둘지, 혹은 검은 블록으로 채울지 확인하는 과정이 필요합니다. 블록이 삭제된 칸이어도 검은 블록으로 채울 수 없는 경우가 있기 때문입니다. \n지워진 칸을 기준으로 위쪽에 삭제되지 않은 블록이 있는지 확인하여 검은 블록을 적절히 채웁니다(삭제되는 블록을 찾는 방향에 따라 조금 다를 수도 있습니다).</p>\n\n  <p>블록이 삭제되면 카운트를 1 증가시키고, 게임 보드의 모든 칸에 대해 삭제될 블록을 찾은 후 카운트된 값을 반환하면 됩니다.</p>\n\n  <p>또 다른 방법으로, 문제의 설명대로 위에서 블록을 떨어뜨려서 없앨 수 있는 블록을 차례대로 찾아서 제거하는 것을 생각해 볼 수 있습니다.</p>\n\n  <p>도형의 모양을 자세히 보면, 제거할 수 있는 도형은 채워야 할 공간이 위쪽으로 열려있는 5가지뿐임을 알 수 있습니다. \n최상단 좌측부터 검사를 시작해 도형이 있는 칸(0보다 큰 값)을 만나면, 주변 값들을 확인해서 제거 가능한 도형 중 하나인지를 체크합니다. \n만약, 제거 가능한 도형 중 하나라면 도형에서 채워야 하는 공간부터 최상단까지 모든 값이 비어있는지를 체크합니다. 모두 비어있다면 이는 없앨 수 있다는 뜻이므로 이 도형을 0으로 채워 제거합니다.</p>\n\n  <p>제거 가능한 도형을 모두 찾을 때까지 이 과정을 반복하고, 도형을 제거할 때마다 카운트를 증가시켜주면 됩니다.</p>\n</blockquote>\n\n<h1 id=\"마무리하며\">마무리하며</h1>\n\n<p>지금까지 1차 코딩 테스트 문제와 풀이에 대해 살펴봤습니다.</p>\n\n<p>아마 문제를 풀어본 분이라면 고개가 끄덕여지는 부분도 있을 것이고, 자신의 풀이와 차이점도 확인할 수 있었을 것 같네요. 모쪼록 이 글이 도움이 되었으면 좋겠습니다.</p>\n\n<p>마지막으로, 5시간 동안 테스트에 응해주신 지원자분들께 감사드립니다. 모두 고생 많으셨고 2차 오프라인 테스트에서 만날 수 있길 바라봅니다. : )</p>\n"
    } ,
  
    {
      "title"    : "코드 페스티벌 2018 본선 이야기",
      "category" : "",
      "tags"     : "code-festival, programming-contest, and coding",
      "url"      : "/2018/09/12/code-festival-2018-round-2/",
      "date"     : "2018-09-12 17:00:00 +0900",
      "content"   : "<h2 id=\"2018-코드-페스티벌-뜨거운-열기와-함께-본선-시작\">2018 코드 페스티벌, 뜨거운 열기와 함께 본선 시작!</h2>\n\n<p>지난 8월 25일 토요일, 카카오 코드 페스티벌 오프라인 본선이 진행됐습니다. 예선에서의 엄청난 경쟁률을 뚫고 당당히 본선에 진출한 64명의 실력자들이 함께 했는데요. 작년과는 다르게 카카오 판교 오피스에서 행사를 개최하여 더 뜻깊은 자리가 되었던 것 같습니다.</p>\n\n<p><a href=\"https://brunch.co.kr/@andkakao/67\" target=\"_blank\">▶ 행사 후기가 궁금하시다면?</a></p>\n\n<p>그럼 본선에 출제되었던 문제와 해법을 알아보도록 하겠습니다.</p>\n\n<h2 id=\"문제-설명-및-풀이\">문제 설명 및 풀이</h2>\n\n<h3 id=\"승부-예측\">승부 예측</h3>\n\n<ul>\n  <li>제출자 62명</li>\n  <li>정답자 62명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15997\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>서로 다른 결과의 경우의 수가 총 3<sup>6</sup> 가지임을 알 수 있습니다. 그러므로 모든 경우를 고려하는 완전 탐색 풀이를 구현하면 됩니다. \n특정 경우에서 동점자가 발생하는 경우가 존재하기 때문에, 동점자가 발생하는 모든 경우를 유의할 필요가 있습니다.</p>\n\n<h3 id=\"카카오머니\">카카오머니</h3>\n\n<ul>\n  <li>제출자 64명</li>\n  <li>정답자 59명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15998\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>모순이 없다고 가정하고, <code class=\"highlighter-rouge\">M</code> 을 구해 봅시다. 편의상 b<sub>0</sub> = 0 으로 둔다면, <code class=\"highlighter-rouge\">i</code> (1 ≤ i ≤ n)번째 로그에서 카카오머니 잔고의 변화량은 b<sub>i</sub> - b<sub>i-1</sub> 입니다.</p>\n\n<p>만약 b<sub>i</sub> - b<sub>i-1</sub> = a<sub>i</sub>라면, <code class=\"highlighter-rouge\">i</code> 번째 로그가 입금인지 출금인지의 여부와 관계없이, 카카오머니 잔고가 a<sub>i</sub> 만큼 변하여 제대로 기록된 것입니다.</p>\n\n<p>하지만, 만약 b<sub>i</sub> - b<sub>i-1</sub> ≠ a<sub>i</sub> 라면, 카카오머니 잔고가 부족하여 통장에서 돈을 가져왔을 것입니다. (이 외의 방법이 없습니다.)</p>\n\n<p>통장에서 가져온 금액은 b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 원입니다. \n문제의 지문에서, 통장에서 돈을 가져올 때에는 <code class=\"highlighter-rouge\">M</code> 원씩을 여러 번 가져오므로, b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 이 <code class=\"highlighter-rouge\">M</code> 의 배수여야 한다는 조건을 얻을 수 있습니다. \n또한, 최종 잔고는 <code class=\"highlighter-rouge\">M</code> 원 미만이므로, b<sub>i</sub> &lt; <code class=\"highlighter-rouge\">M</code> 이라는 조건도 얻을 수 있습니다.</p>\n\n<p>위의 관찰 중 첫 번째 조건을 종합해 보면, <code class=\"highlighter-rouge\">M</code> 으로 가능한 수들은 b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 들의 공약수임을 알 수 있습니다. \n이들 중 두 번째 조건을 만족하려면, <code class=\"highlighter-rouge\">M</code> 이 크면 클수록 좋다는 것을 알 수 있습니다.</p>\n\n<p>따라서, b<sub>i</sub> - (b<sub>i-1</sub> + a<sub>i</sub>) 들의 최대공약수를 구한 뒤, 이것을 <code class=\"highlighter-rouge\">M</code> 으로 놓고, 주어진 로그대로 입출금을 해보면서 모순이 없는지 확인하면 됩니다.</p>\n\n<h3 id=\"뒤집기\">뒤집기</h3>\n\n<ul>\n  <li>제출자 61명</li>\n  <li>정답자 60명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15999\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>문제를 잘 관찰해 보면, 인접한 두 격자의 색이 다른 경우 두 격자의 현재 상태는 초기 상태와 같다는 성질을 발견할 수 있습니다.</p>\n\n<p>증명) 인접한 두 격자의 현재 상태가 <code class=\"highlighter-rouge\">BW</code> 일 때, 원래 <code class=\"highlighter-rouge\">WW</code> 거나 <code class=\"highlighter-rouge\">BB</code> 였다면, 두 격자는 연결되어 있으므로 현재 상태와 같이 달라지는 경우는 발생하지 않습니다. \n원래 <code class=\"highlighter-rouge\">WB</code> 였다면 상태가 바뀔 때 <code class=\"highlighter-rouge\">BW</code> 로 한 번에 바뀔 수 없고, <code class=\"highlighter-rouge\">WW</code> 또는 <code class=\"highlighter-rouge\">BB</code> 를 거쳐야 하므로 불가능합니다. 따라서 초기 상태가 <code class=\"highlighter-rouge\">BW</code> 였음을 알 수 있습니다.</p>\n\n<p>인접한 격자 중 자신과 색이 다른 것이 존재하는 격자들의 경우 위 성질에 의해 색이 정해지고, 그 외의 격자들은 초기 상태에 아무렇게나 칠해져 있어도 현재 상태로 만들 수 있음을 알 수 있습니다. \n(연결된 컴포넌트들의 경계선에 있는 부분은 색이 정해 지므로, 내부는 아무렇게나 칠해져 있어도 경계선과 동일하게 만들 수 있습니다.)</p>\n\n<p>따라서, 가능한 초기 상태의 수는 2<sup>(색이 정해지지 않은 격자의 수)</sup> 가 됩니다.</p>\n\n<h3 id=\"섬\">섬</h3>\n\n<ul>\n  <li>제출자 53명</li>\n  <li>정답자 22명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/16000\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>튜브는 연료를 구하러 망망대해로 나가고 싶으나, 사냥꾼이 어떠한 섬을 점거했을 때 길이 막힐 것이 두려워 걱정하고 있습니다. 튜브는 현재 위치에서 안전하게 망망대해로 나갈 수 있을까요?</p>\n\n<p>이 문제는 풀이의 방향이 크게 두 갈래로 나뉩니다. 하나는 출제진이 의도하였던 풀이이고, 하나는 출제진이 예상하지 못했던 방향의 풀이입니다. 첫 번째 풀이를 중심으로 설명하나, 두 번째 풀이에 대해서도 간단히 짚고 넘어가겠습니다.</p>\n\n<h4 id=\"의도된-풀이--그래프의-절점\">의도된 풀이 : 그래프의 절점</h4>\n\n<p>문제를 다시 요약해 보겠습니다. 우리는 튜브가 도착한 각각의 섬 <code class=\"highlighter-rouge\">v</code> 에 대해서, <code class=\"highlighter-rouge\">v</code> 와 다른 섬 <code class=\"highlighter-rouge\">w</code> 중, <code class=\"highlighter-rouge\">w</code> 에 사냥꾼이 있을 때 <code class=\"highlighter-rouge\">v</code> 에서 최외곽으로 갈 수 있는 경로가 없어지는 <code class=\"highlighter-rouge\">w</code> 가 존재하는가가 궁금한 것입니다. \n결국에는 “경로” 와 “섬” 에 대한 이야기니, 그래프에 풀어놓고 생각해보면 편리하게 문제를 해결할 수 있습니다.</p>\n\n<p>그래프에 있는 모든 4방향으로 인접한 육지와 바다를 Flood-Fill 로 하나의 정점으로 묶어줍시다. 이제 각각의 정점은 “섬” 이거나 “바다” 로 분류될 수 있습니다. “섬” 과 “바다” 가 맞닿아 있으면 간선을 이어줍시다. \n최외곽의 바다를 1번 정점이라고 하면, 우리가 풀고자 하는 문제는 다음과 같습니다.</p>\n\n<ul>\n  <li>그래프 <code class=\"highlighter-rouge\">G</code> 와 튜브가 도착한 각각의 섬 정점 <code class=\"highlighter-rouge\">v</code> 에 대해, <code class=\"highlighter-rouge\">w</code> ≠ <code class=\"highlighter-rouge\">v</code> 가 존재하여, <code class=\"highlighter-rouge\">G</code> 에서 <code class=\"highlighter-rouge\">w</code> 를 제거했을 때 <code class=\"highlighter-rouge\">1</code> 번 정점과 <code class=\"highlighter-rouge\">v</code> 번 정점을 잇는 경로가 존재하지 않는다.</li>\n</ul>\n\n<p>왠지 익숙한 느낌이 들지 않나요? 그래프에서 정점 하나를 제거했을 때 경로가 사라지는 형태의 문제이니, “절점”의 개념을 활용할 수 있다고 생각할 수 있습니다. \n그래프에서 어떠한 정점을 제거하였을 때, 컴포넌트의 개수가 증가하는 정점들을 “절점” 이라고 부릅니다. 절점에 대한 자세한 설명은 지면상 생략하겠으나, 어떠한 정점이 절점인지 아닌지를 판별하는 것은 선형 시간에 가능합니다.</p>\n\n<p>절점 개념을 도입하면, 문제는 다음과 같이 변합니다.</p>\n\n<ul>\n  <li>모든 섬 <code class=\"highlighter-rouge\">v</code> 에 대해서, “절점인 섬” 을 지나지 않고 <code class=\"highlighter-rouge\">1</code> 번 정점에서 <code class=\"highlighter-rouge\">v</code> 번 정점을 방문할 수 있는지 아닌지를 판별하여라.</li>\n</ul>\n\n<p>이는 절점을 구하는 알고리즘을 조금만 응용하면 됩니다. \n1번 정점에서 DFS 를 시작했을 때, 어떠한 점이 절점이면, 해당 점을 거쳐야만 1번 정점으로 갈 수 있는 점들의 집합이 DFS Tree 상의 서브트리로 표현이 됩니다. \n이는 문제가 “서브트리에 있는 정점에 대해서 마킹을 하시오” 의 형태로 환원이 된다는 것을 의미합니다. \n서브트리에 있는 정점은 Euler Tour 번호에서 연속된 구간을 이루기 때문에, 구간에 대한 마킹으로 변환할 수 있으며, 이는 변화값 배열을 사용해서 해결할 수 있습니다.</p>\n\n<h4 id=\"다른-풀이\">다른 풀이</h4>\n\n<p>입력이 결국에는 평면 상의 격자의 모습임을 상기해 보면, 사냥꾼이 점령하고 있는 섬 안에 “둘러싸인” 섬들은 위험한 섬이 된다는 것을 알 수 있습니다. \n즉, 각각의 섬에 대해서 그 섬이 “둘러싸고” 있는 섬들이 무엇인지를 알면 문제를 해결하는 데 조금 더 가까워질 수 있습니다. 둘러싸고 있는 영역을 Flood-Fill 해 주면 되기 때문입니다.</p>\n\n<p>다른 풀이는 이 “둘러싸고 있는 영역” 을 효율적으로 구하는 데 초점을 맞춥니다. \n각각의 섬에 대해서 Flood-Fill 로 해당 섬의 영역을 구해주고, 영역의 빈자리를 찾아낸 후, 해당 빈자리를 다시 Flood-Fill 로 구해주는 것이죠.</p>\n\n<p>직관적으로는 이 부분이 매우 자명하나, 이를 알고리즘으로 옮기는 것은 또 다른 난이도입니다. 여기부터는 출제진도 말을 아끼겠습니다 :D\n위 방법은 절점과 같은 고급 개념이 필요하지 않은 알고리즘이지만, 이러한 부분에서의 난이도가 상당히 있었는지, 초반에 이 문제를 빠르게 푼 대부분의 참가자들은 절점 알고리즘을 사용하였습니다.</p>\n\n<h3 id=\"보물-상자-열기\">보물 상자 열기</h3>\n\n<ul>\n  <li>제출자 18명</li>\n  <li>정답자 12명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/16001\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>먼저, 초기 상태가 회문인 경우에는 답이 모두 0입니다.\n그렇지 않은 경우, 주어진 문자열을 <code class=\"highlighter-rouge\">S[1~N]</code> 이라 할 때, <code class=\"highlighter-rouge\">S[i]</code> 가 <code class=\"highlighter-rouge\">S[N+1-i]</code> 와 다른 최소의 <code class=\"highlighter-rouge\">i</code> 를 <code class=\"highlighter-rouge\">b</code> 라 하고, <code class=\"highlighter-rouge\">e = N-b+1</code> 로 두면 주어진 문자열을 회문으로 만들기 위해서는 <code class=\"highlighter-rouge\">b</code> 번째 석판이나 <code class=\"highlighter-rouge\">e</code> 번째 석판을 교체해야 한다는 것을 알 수 있습니다.</p>\n\n<p>또한 <code class=\"highlighter-rouge\">[b, e]</code> 구간 밖에서는 석판을 교체할 이유가 없으므로 시작 위치가 <code class=\"highlighter-rouge\">i</code> 일 때 소모해야 하는 체력을 <code class=\"highlighter-rouge\">H[i]</code> 라 하면,</p>\n\n<ul>\n  <li><code class=\"highlighter-rouge\">i</code> &lt; <code class=\"highlighter-rouge\">b</code> 인 경우 H[i] = H[b] + (b-i) * c</li>\n  <li><code class=\"highlighter-rouge\">i</code> &gt; <code class=\"highlighter-rouge\">e</code> 인 경우 H[i] = H[e] + (i-e) * c</li>\n</ul>\n\n<p>가 되고 <code class=\"highlighter-rouge\">S[b~e]</code> 에 대해서만 문제를 해결하면 됩니다. <code class=\"highlighter-rouge\">b</code> 와 <code class=\"highlighter-rouge\">e</code> 중 석판 <code class=\"highlighter-rouge\">b</code> 를 교체하는 경우를 생각해 보면 시작 위치가 <code class=\"highlighter-rouge\">x</code> 번째 석판일 때 가능한 경로를 다음과 같은 2가지로 분류할 수 있습니다.</p>\n\n<ul>\n  <li>x-&gt;r-&gt;b  (x에서 오른쪽으로 갔다가 왼쪽으로 이동하여 b로 가는 경우)</li>\n  <li>x-&gt;b-&gt;r  (x에서 왼쪽으로 이동하여 b로 갔다가 오른쪽으로 가는 경우)</li>\n</ul>\n\n<p>두 경우 모두 <code class=\"highlighter-rouge\">[b, r]</code> 의 석판만 교체하여 문자열을 회문으로 만들 수 있어야 가능하고, 또한 <code class=\"highlighter-rouge\">[b, r]</code> 에 회문에서 서로 대응되는 두 석판이 모두 포함되는 경우 교체 시 드는 체력이 작은 쪽을 고르는 것이 항상 이득입니다.</p>\n\n<p>모든 <code class=\"highlighter-rouge\">r</code> 에 대해 <code class=\"highlighter-rouge\">[b, r]</code> 구간을 방문할 때 회문을 만들기 위해 석판을 교체하는 데 드는 체력을 배열 <code class=\"highlighter-rouge\">P[]</code> 에 미리 저장해 놓을 수 있습니다. \n그러면 <code class=\"highlighter-rouge\">x</code> 가 주어졌을 때 <code class=\"highlighter-rouge\">x</code> &lt;= <code class=\"highlighter-rouge\">r</code> 인 모든 <code class=\"highlighter-rouge\">r</code> 에 대해 <code class=\"highlighter-rouge\">P[r] + (r-x) + (r-b)</code> 의 최솟값이 <code class=\"highlighter-rouge\">x-&gt;r-&gt;b</code> 의 경로 중 최적인 값이고, <code class=\"highlighter-rouge\">P[r] + (x-b) + (r-b)</code> 의 최솟값이 <code class=\"highlighter-rouge\">x-&gt;b-&gt;r</code> 의 경로 중 최적인 값입니다. \n이는 <code class=\"highlighter-rouge\">x</code> 를 <code class=\"highlighter-rouge\">e</code> 부터 시작하여 왼쪽으로 한 칸씩 밀면서 계산하면 모든 <code class=\"highlighter-rouge\">x</code> 에 대해서 O(N) 시간에 계산할 수 있으므로 석판 <code class=\"highlighter-rouge\">b</code> 를 교체하는 경우에 소모해야 하는 최소 체력을 O(N) 시간에 계산할 수 있습니다. \n석판 <code class=\"highlighter-rouge\">e</code> 를 교체하는 경우도 대칭적으로 생각하면 마찬가지 방법으로 가능합니다.</p>\n\n<p>따라서 선형 시간에 문제를 해결할 수 있습니다.</p>\n\n<h3 id=\"조용한-생활관-만들기\">조용한 생활관 만들기</h3>\n\n<ul>\n  <li>제출자 7명</li>\n  <li>정답자 0명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/16002\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>먼저, Union 마법을 사용했을 때 사용하기 전보다 더 시끄러워지는 경우는 없습니다. \n처음은 directed rooted tree 형태의 그래프이고, 최종 상태는 Union 마법을 더 이상 쓸 수 없는 상태여야 하므로 모든 도로의 끝점은 트리의 leaf 일 것입니다. \n이 점에 착안하여 생각해보면 이 문제는 directed rooted tree 의 edge 들을, leaf 를 끝점으로 하는 여러 경로들로 나누어 각 경로의 시작점과 끝점에 있는 건물의 사람 수의 곱을 최소로 만드는 문제입니다. \n즉, 건물 <code class=\"highlighter-rouge\">i</code> 에 사는 사람의 수를 <code class=\"highlighter-rouge\">C[i]</code> 라 할 때, 최종 상태의 모든 경로 <code class=\"highlighter-rouge\">u-&gt;v</code> 에 대해 <code class=\"highlighter-rouge\">C[u]*C[v]</code> 의 합을 최소화하면 됩니다.</p>\n\n<p>처음에 주어진 directed rooted tree 에서, root 가 아닌 노드 <code class=\"highlighter-rouge\">u</code> 를 생각해봅시다. 또한, <code class=\"highlighter-rouge\">u</code> 를 root 로 하는 subtree 를 subtree(u) 라고 합시다. \n<code class=\"highlighter-rouge\">u</code> 의 부모에서 <code class=\"highlighter-rouge\">u</code> 로 들어오는 간선이 있으므로, 최종 상태에는 <code class=\"highlighter-rouge\">u</code> 의 조상 중 하나에서 subtree(u)에 포함되는 leaf 로 가는 경로가 하나 있을 것이고, 그 경로에 포함되지 않는 subtree(u)의 edge 들은 subtree(u) 내부의 경로가 될 것입니다.</p>\n\n<p>결론적으로, subtree(u) 내부의 edge 들이 최종적으로 어떤 경로에 포함될지 결정된다면, 외부에 영향을 끼치는 요소는 <code class=\"highlighter-rouge\">u</code> 의 조상 중 하나와 연결될 leaf 의 건물에 있는 사람 수 뿐입니다. \n따라서, 다음과 같은 다이나믹 프로그래밍을 생각할 수 있습니다.</p>\n\n<ul>\n  <li>D[u][l] : <code class=\"highlighter-rouge\">u</code> 의 조상 중 하나와 연결되는 leaf 가 <code class=\"highlighter-rouge\">l</code> 일 때, <code class=\"highlighter-rouge\">u</code> 내부 경로들에서 만들어지는 시끄러운 정도의 최솟값</li>\n</ul>\n\n<p>점화식은 다음과 같습니다.</p>\n\n<ul>\n  <li>u = l : D[u][l] = 0</li>\n  <li>u ≠ l : <code class=\"highlighter-rouge\">u</code> 의 자식 중 <code class=\"highlighter-rouge\">x</code> 가 <code class=\"highlighter-rouge\">l</code> ∈ subtree(x)을 만족할 때,<br />\nD[u][l] = D[x][l] + (<code class=\"highlighter-rouge\">u</code> 의 <code class=\"highlighter-rouge\">x</code> 가 아닌 모든 자식 <code class=\"highlighter-rouge\">v</code> 에 대해, (D[v][l’]+C[u]C[l’]) 의 최솟값들의 합<br />\n(단, <code class=\"highlighter-rouge\">l'</code> 은 subtree(v)의 leaf))</li>\n</ul>\n\n<p>각 자식 노드 <code class=\"highlighter-rouge\">v</code> 에 대해 <code class=\"highlighter-rouge\">D[v][l'] + C[u]C[l']</code> 이 최소가 되는 <code class=\"highlighter-rouge\">l'</code> 을 미리 구해놓을 수 있으므로, 시간 복잡도는 각 노드 <code class=\"highlighter-rouge\">u</code> 에 대해 subtree(u)의 leaf <code class=\"highlighter-rouge\">l</code> 을 선택하는 경우의 수인 O(N<sup>2</sup>)가 됩니다.\n위 다이나믹 프로그래밍은 O(N<sup>2</sup>)의 시간 복잡도를 가지므로, 시간 초과가 발생하게 됩니다. 이를 줄이기 위해서는 한 가지 관찰이 필요합니다.</p>\n\n<p>subtree(u)의 모든 leaf <code class=\"highlighter-rouge\">l</code> 에 대해, 좌표평면 상에서 <code class=\"highlighter-rouge\">y = C[l] * x + D[u][l]</code> 라는 직선을 그었다고 생각해봅시다. 0 이상의 모든 <code class=\"highlighter-rouge\">x</code> 에 대해 그 <code class=\"highlighter-rouge\">x</code> 에서 함숫값이 최소가 되는 직선을 구했다고 합시다. \n만약 어떤 <code class=\"highlighter-rouge\">x</code> 에서도 함숫값이 최소가 되지 않는 직선이 있다면, 그 직선은 최적해를 구하는 데에 있어 쓸모가 없습니다. 그 leaf 가 <code class=\"highlighter-rouge\">u</code> 의 어느 조상과 연결되든 간에 더 좋은 방법이 존재하기 때문입니다. \n따라서 정점 <code class=\"highlighter-rouge\">u</code> 에 대해 subtree(u)의 모든 leaf 에 대한 값을 저장할 필요가 없고, 위에서 설명한 직선들의 아래쪽 convex hull 만을 들고 있으면 충분합니다.</p>\n\n<p>앞에서 설명한 DP를 이 convex hull 을 이용해서 할 수 있는데, 먼저 <code class=\"highlighter-rouge\">u</code> 의 모든 자식 <code class=\"highlighter-rouge\">v</code> 에 대해 <code class=\"highlighter-rouge\">D[v][l'] + C[u]C[l']</code> 의 최솟값은 <code class=\"highlighter-rouge\">v</code> 의 아래쪽 convex hull 이 <code class=\"highlighter-rouge\">x = C[u]</code> 와 만나는 부분임을 쉽게 알 수 있습니다. \n따라서 이를 미리 계산해 놓을 수 있습니다. 또한 <code class=\"highlighter-rouge\">u</code> 의 자식 <code class=\"highlighter-rouge\">v</code> 에 대해 subtree(v)에 포함되는 leaf 가 <code class=\"highlighter-rouge\">u</code> 의 조상과 연결되는 경우는 <code class=\"highlighter-rouge\">v</code> 의 convex hull 이 일정 크기만큼(정확히는 <code class=\"highlighter-rouge\">v</code> 가 아닌 모든 자식 <code class=\"highlighter-rouge\">c</code> 에서 <code class=\"highlighter-rouge\">D[c][l'] + C[c]C[l']</code> 의 최솟값의 합만큼) 위로 올라간 것임을 알 수 있습니다. \n따라서, 자식들에 저장된 convex hull 들을 y 축 방향으로 평행 이동시킨 후에 모두 합쳐서 convex hull 을 다시 구할 수 있다면 앞서 설명한 DP 와 정확하게 같은 것을 할 수 있는 것입니다.</p>\n\n<p>먼저 set 을 이용해 Dynamic Convex Hull 자료구조를 만들면 O(log N) 시간에 직선을 추가하는 연산을 수행할 수 있고, \n어떤 x 좌표가 주어졌을 때 convex hull 에서 해당하는 y 좌표를 이분 탐색을 이용해 O(log<sup>2</sup>N) 시간에 찾을 수 있습니다.</p>\n\n<p>y축 방향으로 얼마만큼 평행이동되었는지는 따로 저장해 놓으면 쉽게 관리할 수 있습니다.\nx 좌표가 주어졌을 때 convex hull 에서 y 좌표를 찾는 연산은 <code class=\"highlighter-rouge\">D[v][l'] + C[u]C[l']</code> 의 최솟값을 찾을 때 사용하므로 총 O(N)번 쓰게 되어 여기서 시간 복잡도 O(N log<sup>2</sup>N)가 발생합니다. \n자식들의 convex hull 들을 합쳐야 하는데, 자식들 중 가장 직선이 많은 convex hull 에 다른 자식들의 convex hull 의 직선을 삽입하는 small-to-large 방식으로 이를 해결할 수 있습니다. \n여기에서 직선 삽입은 Heavy-Light Decomposition 과 같은 원리로 최대 O(N logN)번만 수행됩니다. 따라서, 여기서 발생하는 시간 복잡도는 O(N log<sup>2</sup>N)입니다.</p>\n\n<p>따라서, 총 시간 복잡도 O(N log<sup>2</sup>N)에 문제를 해결할 수 있습니다.</p>\n\n<h3 id=\"자석-장난감\">자석 장난감</h3>\n\n<ul>\n  <li>제출자 8명</li>\n  <li>정답자 1명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/16003\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>이 문제는 그래프에서 규칙에 따라 모든 노드를 제거할 수 있는지 확인하는 문제입니다.<br />\n제거하는 규칙은, 어떤 노드 <code class=\"highlighter-rouge\">X</code> 가 제거될 때 그 노드에 연결된 다른 모든 노드 <code class=\"highlighter-rouge\">A, B, …, D</code> 가 서로 모두 연결되어 있어야 한다는 것입니다. \n이 조건에서 <code class=\"highlighter-rouge\">X, A, B, …, D</code> 는 하나의 Clique(모든 노드 쌍이 연결된 부분 그래프)를 이룬다는 것을 알 수 있습니다. \n그래프의 한 상태에서 제거될 조건을 만족하는 노드는 어느 것을 먼저 제거하더라도 상관없다는 것을 짐작할 수 있고 증명할 수 있습니다. \n하지만, 이렇게 조건을 하나하나 확인하면서 제거할 수 있는 노드를 찾아 나가며 진행하는 것은 매우 느린 방법이 됩니다.</p>\n\n<p>빠른 방법 중 하나는 노드를 제거하는 “특정한 순서”를 찾고, 그 순서에 따라서 노드를 제거했을 때 조건을 만족하면서 모든 노드를 제거할 수 있음을 확인하는 것입니다. \n이 “특정한 순서”는, 만약 모든 노드를 제거할 수 있는 순서가 하나라도 있다면 반드시 모든 노드를 제거할 수 있는 순서가 된다는 성질을 가집니다. \n모든 노드를 제거할 수 있는 그래프는 Clique 들이 서로 노드를 공유하는 모양으로만 구성되어 있어야 한다는 것을 어렵지 않게 짐작할 수 있고 증명할 수 있습니다.</p>\n\n<p>비교적 단순하게 두 개의 Clique <code class=\"highlighter-rouge\">P</code> 와 <code class=\"highlighter-rouge\">Q</code> 가 일부 노드를 공유하고 있는 그래프로 설명해 보겠습니다. \n이 그래프는 모든 노드를 제거하는 것이 가능한 그래프임이 당연합니다. 노드들의 집합 <code class=\"highlighter-rouge\">P-Q</code>, <code class=\"highlighter-rouge\">Q-P</code>, <code class=\"highlighter-rouge\">P∩Q</code> 를 생각해 봅시다. \n<code class=\"highlighter-rouge\">P-Q</code> 나 <code class=\"highlighter-rouge\">Q-P</code> 에 있는 노드가 가장 먼저 제거되는 것은 가능하지만, <code class=\"highlighter-rouge\">P∩Q</code> 에 있는 노드가 가장 먼저 제거되는 것은 불가능합니다. \n<code class=\"highlighter-rouge\">P-Q</code> 나 <code class=\"highlighter-rouge\">Q-P</code> 중 한 집합이라도 모두 제거되어야 <code class=\"highlighter-rouge\">P∩Q</code> 에 있는 노드가 제거될 수 있음을 알 수 있습니다.</p>\n\n<p>이제, 아무 노드에서나 시작해서 그래프를 탐색하면서 방문하는 순서대로 노드들을 출력합니다. \n노드가 출력되면 노드에 연결된 다른 노드들에 모두 카운터를 1 증가시키는 연산을 합니다. 카운터 값이 큰 노드부터 무조건 다음에 출력합니다.</p>\n\n<p>만약 이 탐색이 <code class=\"highlighter-rouge\">P-Q</code>(혹은 <code class=\"highlighter-rouge\">Q-P</code>) 에 있는 노드에서 시작된다면 <code class=\"highlighter-rouge\">P</code>(혹은 <code class=\"highlighter-rouge\">Q</code>)가 모두 출력된 다음에야 나머지 노드가 출력될 수 있습니다.<br />\n만약 이 탐색이 <code class=\"highlighter-rouge\">P∩Q</code> 에 있는 노드에서 시작된다면, 탐색이 최초로 <code class=\"highlighter-rouge\">P-Q</code>(혹은 <code class=\"highlighter-rouge\">Q-P</code>) 에 들어가는 순간 <code class=\"highlighter-rouge\">P-Q</code>(혹은 <code class=\"highlighter-rouge\">Q-P</code>) 에 있는 노드가 모두 출력된 다음에야 <code class=\"highlighter-rouge\">Q-P</code>(혹은 <code class=\"highlighter-rouge\">P-Q</code>) 에 있는 노드가 출력됨을 알 수 있습니다.</p>\n\n<p>모든 경우를 증명하는 것은 복잡하지만 이런 방식으로 출력하면, 출력의 반대 순서가 반드시 제거 가능한 순서가 됨을 알 수 있습니다.</p>\n\n<p>특정한 하나의 순서를 찾았으면 이 순서가 규칙을 지키는 제거 순서인지를 확인해야 합니다. \n제거 과정에서 매번 규칙을 전부 확인하면 시간이 아주 오래 걸리게 됩니다. \n하지만, 이 과정을 살펴보면 동일한 노드 쌍의 연결 관계를 반복적으로 확인하고 있음을 알 수 있습니다. \n동적 프로그래밍과 비슷한 방법으로 반복적으로 확인하는 것을 한 번만 확인하도록 줄여서 빠른 시간에 규칙을 지키는지 확인하는 것이 가능합니다.</p>\n\n<p>이러한 두 가지 과정을 거쳐서 O((N+M)logN) 시간 알고리즘을 구현할 수 있습니다.<br />\n대회에서는 O(N sqrt(N)) 정도 알고리즘도 통과할 수 있는 수준으로 채점 데이터가 만들어졌습니다.</p>\n\n<h3 id=\"헬리콥터\">헬리콥터</h3>\n\n<ul>\n  <li>제출자 4명</li>\n  <li>정답자 0명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/16004\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>이 문제는 직교 다각형 형태로 주어진 영역을 왼쪽에서 오른쪽으로 비행할 때 단 한 번의 사선 방향을 제외하고는 모두 수직이나 수평으로만 움직일 수 있다고 가정하고 가장 짧은 거리를 찾는 문제입니다. \n이 문제의 답을 구현하는 것은 매우 어렵지만 아이디어를 설명하는 것은 비교적 간단합니다.</p>\n\n<p>우선, 사선 방향 없이 수직 수평으로만 움직이는 경로를 생각해 봅시다. 주어진 영역 안에서 그러한 최단 경로는 매우 많습니다. \n최단 경로들을 모두 그렸다고 하면 그려진 경로들은 모여서 하나의 영역을 만들게 됩니다. 이 영역을 “새 영역”이라고 부릅시다. 새 영역을 구하는 것은 O(N) 시간에 가능합니다.</p>\n\n<p>단 한 번의 사선 방향으로의 움직임(사선 성분)에 대해 다음 세 가지를 확인할 수 있습니다.</p>\n\n<ul>\n  <li>(1) 최적인 사선 성분은 새 영역 안에 있다.</li>\n  <li>(2) 최적인 사선 성분은 새 영역의 경계를 끝점으로 가진다.</li>\n  <li>(3) 최적인 사선 성분은 새 영역의 꼭짓점과 교차한다.</li>\n</ul>\n\n<p>이 세 가지 성질에서 다음과 같은 알고리즘을 만들 수 있습니다.<br />\n새 영역의 각 꼭짓점에서 그 꼭짓점에 걸치면서 그 꼭짓점에서 보이는 영역의 경계 위의 두 점을 잇는 모든 선분을 확인합니다. \n각 꼭짓점에서는 O(N)개의 다른 꼭짓점이 보입니다. 선분들 중 적어도 한쪽이 꼭짓점인 것들은 따라서 O(N)개가 됩니다. 이들 중 최적인 것이 있다면 쉽게 확인할 수 있습니다. \n이들 중 최적인 것이 없다면 앞에서 확인한 선분들 사이를 회전시켜 가면서 최적인 선분을 찾아볼 수 있습니다. \n선분을 회전할 때 사선이 만들어 내는 이익은 증가나 감소를 최대 한 번 바꿀 수 있다는 것을 알아낼 수 있어 삼분 탐색으로 충분한 오차 이내까지 선분을 찾아 내려갈 수 있습니다.</p>\n\n<p>이러한 방법으로 O(N<sup>2</sup> logN * log10<sup>9</sup>) 시간이 걸리는 알고리즘을 만들 수 있습니다.<br />\n대회에서는 O(N<sup>3</sup>) 정도 되는 알고리즘도 통과할 수 있는 수준으로 채점 데이터가 만들어졌습니다.</p>\n\n<h2 id=\"결과-발표\">결과 발표</h2>\n\n<p>그럼 이제, 코드 페스티벌 본선 결과를 공개합니다! 본선은 예선과 같은 방식으로 채점이 진행되었으며, 1등은 출제된 8문제 중 6문제를 풀어주셨습니다.</p>\n\n<p><a href=\"http://t1.kakaocdn.net/codefestival/2018-round-2-scoreboard/index.html\" target=\"_blank\">▶ 순위표 보러 가기</a></p>\n\n<p>사전에 공지된 대로 우수한 성적을 거둔 상위 31명의 참가자에게 상장 및 상금이 수여되었습니다. 아쉽게 수상권에 들지 못한 분들을 위해 다양한 특별상도 준비했는데요, 수상하신 모든 분들 축하드립니다!</p>\n\n<p>마지막으로 작년에 비해 본선 문제의 난이도가 높다는 피드백이 많았는데요, 그럼에도 불구하고 끝까지 코드 페스티벌에 적극적으로 참여해주신 분들께 감사드립니다.</p>\n\n<p>앞으로 있을 개발자 행사에도 많은 관심 부탁드립니다 :)</p>\n"
    } ,
  
    {
      "title"    : "2019 카카오 블라인드 신입 개발자 공채가 시작됩니다!",
      "category" : "",
      "tags"     : "recruitment and intro",
      "url"      : "/2018/08/28/employeement-2019/",
      "date"     : "2018-08-28 10:00:00 +0900",
      "content"   : "<p>카카오는 여전히 같은 생각입니다. \n개발자가 자신의 가치를 증명할 수 있는 것은 자소서나 스펙이 아니라 코드라고 말이죠!</p>\n\n<p>올해는 카카오를 포함하여 5개 기업이 함께 합니다. \n지금 바로 도전하세요! new developer coming!</p>\n\n<p><img src=\"/files/recruit-2019.jpeg\" alt=\"image\" /></p>\n\n<h3 id=\"2019-카카오-블라인드-신입-개발자-공채\">[2019 카카오 블라인드 신입 개발자 공채]</h3>\n\n<p>▶ 접수 기간 : 8월 27일 (월) 15:00 ~ 9월 11일 (화) 23:59 <br />\n▶ 지원 접수 : www.welcomekakao.com <br />\n▶ 문의 사항 : apply@kakaocorp.com <br />\n▶ 모집 회사 : (주)카카오 / (주)카카오 게임즈 / (주)카카오 모빌리티 / (주)카카오페이지 / (주)카카오 페이 <br />\n(총 5개 기업 중 1개 기업에 지원 가능)</p>\n\n<p>2019 카카오 신입 개발자 공채는 스펙보다는 성장 가능성과 잠재력, 창의성 등이 뛰어난 신입 개발자 분들을 선발하기 위해 학력, 경력 등 스펙이 아닌 코딩 능력으로만 검증하는 ‘블라인드’ 전형으로 실시될 예정입니다.</p>\n\n<p>블라인드 전형 취지에 맞게 응시자는 학력, 나이, 성별, 경력 등을 기입하지 않고 이름/메일/ 연락처 등만 입력한 후 본인 계정을 생성하면 코딩 테스트에 응시할 수 있습니다!</p>\n\n<p>올해는 (주)카카오, (주)카카오게임즈, (주)카카오모빌리티, (주)카카오페이지, (주)카카오페이 5개의 기업이 신입 공채를 함께 진행합니다.</p>\n\n<p>지원자는 서류 전형 없이 9월15일부터 코딩테스트를 볼 수 있으며, \n이후 오프라인 코딩 테스트, 1차 및 2차 인터뷰가 순차적으로 진행됩니다. 11월 중 최종 합격 발표 예정이며, 합격자들은 오리엔테이션을 거쳐 내년 1월 정식 입사하게 됩니다. (기업 별로 일자는 상이할 수 있습니다)</p>\n\n<p>카카오 블라인드 공개 채용과 관련한 자세한 내용은 www.welcomekakao.com에서 확인, 지원 가능합니다. \n개발에 대한 열정과 창의성을 갖춘 많은 분들의 지원을 기다립니다 :)</p>\n\n<p><a href=\"https://welcomekakao.com\" target=\"_blank\">▶카카오 블라인드 신입 개발자 공채 지원하러가기</a></p>\n\n"
    } ,
  
    {
      "title"    : "코드 페스티벌 2018 예선전 이야기",
      "category" : "",
      "tags"     : "code-festival, programming-contest, and coding",
      "url"      : "/2018/08/09/code-festival-2018-round-1/",
      "date"     : "2018-08-09 17:00:00 +0900",
      "content"   : "<h2 id=\"카카오-코드-페스티벌-예선전-많은-관심-감사합니다\">카카오 코드 페스티벌 예선전, 많은 관심 감사합니다!</h2>\n\n<p>작년에 이어 두 번째로 진행된 카카오 코드 페스티벌, 온라인 예선이 지난 8월 4일 토요일에 진행됐습니다. 작년보다 더욱 많은 6,000여 명의 참가자들이 6시간 동안 뜨거운 열정을 발휘했는데요, 특히 실시간으로 바뀌는 스코어보드를 보면서 치열한 접전을 느낄 수 있었습니다. 여기 예선 문제와 해설, 그리고 결과를 공유합니다. 참가해주신 모든 모든 분들께 감사드립니다!</p>\n\n<h2 id=\"문제-설명-및-풀이\">문제 설명 및 풀이</h2>\n\n<h3 id=\"상금-헌터\">상금 헌터</h3>\n\n<ul>\n  <li>제출자 3120명</li>\n  <li>정답자 2686명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15953\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>대회에 참가해서 얼마의 상금을 받을 수 있을지를 계산하는 문제로, 주어진 조건대로 구현하면 됩니다. <code class=\"highlighter-rouge\">if</code>문을 사용해서, a와 b가 어떤 범위가 있는지에 따라 상금을 구하거나, 크기가 101인 배열 <code class=\"highlighter-rouge\">A[0..101]</code>와 65인 배열 <code class=\"highlighter-rouge\">B[0..64]</code> 두 개를 만들어서, 각각 1회/2회 대회에서 i등을 하면 얼마의 상금을 받는지를 저장한 뒤 계산하는 방법 등이 있습니다.</p>\n\n<h3 id=\"인형들\">인형들</h3>\n\n<ul>\n  <li>제출자 2138명</li>\n  <li>정답자 942명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15954\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>길이가 N인 수열이 주어졌을 때, 이 중 K개 이상의 연속된 수를 선택하여 표준편차를 최소로 만드는 문제입니다. 범위가 작기 때문에 정의된 대로 직접 계산해도 되고, 이를 좀 더 효율적으로 계산할 수도 있습니다.</p>\n\n<p><strong>Naive: O(N<sup>3</sup>)</strong></p>\n\n<p>모든 경우를 다 고려하여 구현해보는 방법입니다. j - i + 1 ≥ K, 1 ≤ i, j ≤ N 을 만족하는 모든 i, j에 대해서 다음과 같은 과정을 수행하면 됩니다.</p>\n\n<ul>\n  <li>m = (a[i] + a[i+1] + … + a[j]) / N</li>\n  <li>v = ((a[i] - m) * (a[i] - m) + … + (a[j] - m) * (a[j] - m)) / N</li>\n</ul>\n\n<p>참고로, 여기서 m, v는 각각 (산술) 평균과 분산을 의미하며, 문제에 나와있는 식과 같습니다.  그 후 구한 v 중에서 최솟값을 구하고 이 값의 음이 아닌 제곱근을 출력하면 됩니다.</p>\n\n<p>가능한 (i, j)의 가짓수가 O(N<sup>2</sup>)이므로, 모든 (i, j)에 대하여 평균과 분산을 구하는 프로그램의 시간복잡도는 O(N<sup>3</sup>)이 됩니다.</p>\n\n<p><strong>O(N<sup>2</sup>)</strong></p>\n\n<p>(분산) = (제곱의 평균) - (평균) * (평균) 이라는 성질이 알려져 있습니다. 그러므로 누적 합 배열과 제곱의 누적 합 배열을 만들면, j - i + 1 ≥ K, 1 ≤ i, j ≤ N 을 만족하는 모든 i, j에 대해서 평균과 분산을 O(1)의 시간에 구할 수 있습니다.</p>\n\n<p>가능한 (i, j)의 가짓수가 O(N<sup>2</sup>)이므로, O(N<sup>2</sup>)의 시간복잡도로 문제를 풀 수 있습니다.</p>\n\n<p>그 외에 추가로 고려해야 할 사항은 다음과 같습니다.</p>\n<ul>\n  <li>인형을 K개를 선택하는 것이 아니라 K개 이상을 선택해야 한다는 점이 있는데, 의도하지 않게 많은 분들이 처음에 이러한 것을 간과한 것으로 보입니다.</li>\n  <li>절대/상대 오차가 10<sup>-6</sup>이므로, 실수의 정밀도 관련 문제에 대해 어느 정도 고려할 필요가 있습니다.\n    <ul>\n      <li>C++ 기준으로, float를 이용하여 O(N<sup>3</sup>)을 적용하면 정답을 받지 못합니다. double / long double을 사용하면 정답을 받을 수 있습니다.</li>\n      <li>최대한 실수 연산의 수를 줄이는 것이 좋습니다. 예를 들어, 평균을 구할 때에는 수들의 합을 정수형 변수에 저장한 후 N으로 나누는 것이 실수형 변수를 이용하여 연산하는 것에 비해서 좀 더 정확하게 구할 수 있습니다.</li>\n    </ul>\n  </li>\n  <li>Python으로 구현하는 경우, 다른 언어들에 비해 실행 시간이 더 걸리기 때문에, O(N<sup>3</sup>) 풀이를 구현하면 시간 초과를 받게 될 수 있습니다.</li>\n</ul>\n\n<h3 id=\"숏코딩\">숏코딩</h3>\n\n<ul>\n  <li>제출자 235명</li>\n  <li>정답자 50명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15956\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>문제의 조건에 맞게 생성된 논리식이 입력되었을 때, 이 식과 동치인 논리식 중 가장 짧은 논리식을 찾는 문제입니다. <code class=\"highlighter-rouge\">==</code>과 <code class=\"highlighter-rouge\">!=</code>를 나누어 생각합니다.</p>\n<ul>\n  <li><code class=\"highlighter-rouge\">==</code>:  각 단항식을 정점으로, <code class=\"highlighter-rouge\">&lt;X&gt;==&lt;Y&gt;</code>를 <code class=\"highlighter-rouge\">&lt;X&gt;</code>와 <code class=\"highlighter-rouge\">&lt;Y&gt;</code>를 잇는 양방향 간선으로 생각한 그래프에서 한 컴포넌트에 속한 정점들은 모두 값이 같아야 합니다. 이는 <code class=\"highlighter-rouge\">==</code>가 동치관계(equivalence relation)이기 때문입니다.\n    <ul>\n      <li>한 컴포넌트에 있는 단항식들을 u<sub>1</sub>, u<sub>2</sub>, …, u<sub>n</sub>이라고 하고, 그 중 길이가 가장 짧은 것을 u<sub>i</sub>라고 하면, u<sub>i</sub>와 다른 모든 정점을 잇는 n-1개의 간선만 있어도 정점들을 똑같이 묶을 수 있고, 이렇게 하는 것이 가장 길이가 짧습니다. 컴포넌트의 크기가 1이라면 (<code class=\"highlighter-rouge\">1==1</code>, <code class=\"highlighter-rouge\">a==a</code> 등으로 가능) 그 컴포넌트는 출력에 포함되지 않아야 합니다.</li>\n      <li>단, 같은 컴포넌트에 2개 이상의 <strong>정수</strong>가 있다면, 조건문은 항상 <code class=\"highlighter-rouge\">false</code>를 반환합니다.</li>\n    </ul>\n  </li>\n  <li><code class=\"highlighter-rouge\">!=</code>: <code class=\"highlighter-rouge\">&lt;X&gt;!=&lt;Y&gt;</code>가 있다고 가정하면,\n    <ul>\n      <li><code class=\"highlighter-rouge\">&lt;X&gt;</code>와 <code class=\"highlighter-rouge\">&lt;Y&gt;</code>를, 같은 <code class=\"highlighter-rouge\">==</code> 컴포넌트에 속한 가장 길이가 짧은 단항식으로 교체할 수 있습니다.</li>\n      <li>(교체한 이후) 똑같은 <code class=\"highlighter-rouge\">!=</code> 조건문이 여러 개 있다면 그 중 하나만 남겨둘 수 있습니다.</li>\n      <li><code class=\"highlighter-rouge\">&lt;X&gt;</code>와 <code class=\"highlighter-rouge\">&lt;Y&gt;</code>가 같은 <code class=\"highlighter-rouge\">==</code> 컴포넌트에 속한다면, 조건문은 항상 <code class=\"highlighter-rouge\">false</code>를 반환하므로, 이와 동치인 가장 짧은 조건문(ex: <code class=\"highlighter-rouge\">x!=x</code>, <code class=\"highlighter-rouge\">4==7</code>)을 출력해야 합니다.</li>\n      <li><code class=\"highlighter-rouge\">&lt;X&gt;</code>가 속하는 <code class=\"highlighter-rouge\">==</code> 컴포넌트에 정수가 포함되어 있고, <code class=\"highlighter-rouge\">&lt;Y&gt;</code>가 속하는 <code class=\"highlighter-rouge\">==</code> 컴포넌트에도 정수가 포함되어 있다면, 해당 비교 연산은 결국 서로 다른 두 정수를 비교하고 있으므로 필요가 없고, 따라서 제거할 수 있습니다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>위의 과정에서 비교 연산들이 모두 불필요하다고 판단되어 제거되었다면, 조건문은 항상 <code class=\"highlighter-rouge\">true</code>를 반환하는 식이 됩니다.  항상 <code class=\"highlighter-rouge\">true</code>나 <code class=\"highlighter-rouge\">false</code>를 반환하는 가장 짧은 조건문은 길이가 4이며, 각각 <code class=\"highlighter-rouge\">T==T</code>와 <code class=\"highlighter-rouge\">0!=0</code>의 예시가 있습니다.</p>\n\n<h3 id=\"부스터\">부스터</h3>\n\n<ul>\n  <li>제출자 603명</li>\n  <li>정답자 102명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15955\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>N개의 체크포인트 사이를 규칙에 맞게 이동하는 방법이 있는지를 찾는 문제입니다. 체크포인트의 수와 질의의 수 모두 최대 25만 개로 매우 많으므로 단순한 방법으로는 시간 안에 답을 구하기가 매우 힘들기 때문에, 다음과 같이 단계별로 알고리즘을 개선시켜볼 수 있습니다.</p>\n\n<p><strong>O(QN<sup>2</sup>)</strong></p>\n\n<p>문제를 있는 그대로 해석하면, 각각의 체크포인트에서 HP 재충전 / 부스터 재충전 여부를 모두 저장해야 하는 아주 복잡한 문제가 됩니다. 이 정보들을 최대한 간소화할 수 있을까요?</p>\n\n<ul>\n  <li><strong>각각의 체크포인트에서 HP / 부스터의 재충전 여부를 기억할 필요가 없습니다.</strong>  어떠한 체크포인트에 두 번 이상 방문하는 경로가 있다면, 그 체크포인트를 마지막으로 빠져나간 방법을 처음부터 사용하면 됩니다. 그렇다면 임의의 체크포인트에는 많아야 한 번만 방문해도 답을 찾을 수 있고, 이 때 HP / 부스터를 재충전하지 않아서 손해를 볼 일이 없습니다. 고로, 체크포인트에 방문했다는 것은 HP / 부스터를 재충전했다는 것과 동일합니다.</li>\n  <li>체크포인트 간을 이동할 때 부스터는 많아야 한 번밖에 쓸 수 없는데, 처음에 부스터를 무조건 켜도 손해를 보지 않습니다. 처음에 걸어간 후 부스터를 사용하는 경로는, 똑같이 평행이동 시켜서 처음에 부스터를 사용한 후 걸어가는 경로로 바꿔줄 수 있기 때문입니다. 고로 처음에 부스터를 잘 켜서 걷는 거리를 최소화하는 문제인데, X좌표와 Y좌표 차 중에서 큰 쪽을 줄여나가는 전략이 유효하므로, <strong>두 체크포인트 (X<sub>u</sub>, Y<sub>u</sub>)와 (X<sub>v</sub>, Y<sub>v</sub>)를 오갈 때 걸어가야 하는 최소 거리는 min(|X<sub>u</sub> - X<sub>v</sub>|, |Y<sub>u</sub> - Y<sub>v</sub>|)입니다.</strong></li>\n</ul>\n\n<p>이 관찰을 통해서 문제는 그래프 탐색 문제로 환원됩니다. 각각의 쿼리가 주어졌을 때, min(|X<sub>u</sub> - X<sub>v</sub>|, |Y<sub>u</sub> - Y<sub>v</sub>|)가 주어진 HP 제한 이하인 쌍에 대해서 양방향 간선이 있다고 생각하고, 깊이 우선 / 너비 우선 탐색을 사용해서 문제를 해결할 수 있습니다. 시간 제한을 맞추기에는 너무 느린 알고리즘이지만, 좋은 시작점으로 삼을 수 있겠죠.</p>\n\n<p><strong>O(N log N + QN)</strong></p>\n\n<p>현재 사용하는 방법의 문제점 중 하나는, 고려해야 할 간선의 개수가 O(N<sup>2</sup>)개에 육박할 정도로 많다는 것입니다. 이를 줄이기 위해서는 다음과 같은 아이디어가 필요합니다.</p>\n\n<p>일단, 간선을 이을 때 min(|X<sub>u</sub> - X<sub>v</sub>|, |Y<sub>u</sub> - Y<sub>v</sub>|) 비용의 간선 하나를 잇는 대신 |X<sub>u</sub> - X<sub>v</sub>|, |Y<sub>u</sub> - Y<sub>v</sub>| 비용의 간선 두개를 잇는다고 생각해 봅시다. 이렇게 해도 둘 중 비용이 적은 간선을 고를 것이기 때문에 답에는 변화가 없고, 식은 단순해 집니다.</p>\n\n<p>위 그래프에서 X좌표 차이로 이루어진 간선들만 생각해 봅시다. 그러한 간선들만 놓고 보았을 때 Y좌표는 중요한 요인이 아니기 때문에, 우리는 X축 수직선에 점들을 찍어놓고, 두 점의 거리차로 간선을 이었다고 생각할 수 있습니다. 그렇다면, 수직선 상에 인접하지 않은 두 점 간에 간선을 이을 필요가 있을까요? 인접한 정점을 타고서도 해당 위치로 도달할 수 있기에, 굳이 큰 가중치를 사용해서 수직선 상에 인접하지 않은 두 점을 오갈 필요가 없습니다.</p>\n\n<p>같은 이야기는 Y좌표 차이로 이루어진 간선들에 대해서도 똑같이 적용됩니다. 이로써 얻을 수 있는 결론은 다음과 같습니다.</p>\n\n<p>“<strong>X좌표 순으로 정렬했을 때 인접한 N-1개의 쌍과, Y좌표 순으로 정렬했을 때 인접한 N-1개의 쌍만 고려해도 된다.</strong>”</p>\n\n<p>이제, 각각의 좌표로 정렬한 후, 인접한 쌍에 대해서만 간선을 이어주면 된다는 결론에 도달합니다. 그래프의 크기가 작아졌으니, 훨씬 더 문제를 해결하기 수월해졌죠. 물론, 여전히 탐색을 일일이 해 주기에는 쿼리의 수가 너무 많습니다.</p>\n\n<p><strong>O(N log N + Q log Q)</strong></p>\n\n<p>복잡도를 줄이는 전략이 여러 가지가 있으나, 이 중 가장 간단한 전략은 모든 쿼리를 X의 오름차순으로 정렬하는 것입니다. 결국 각각의 쿼리가 의미하는 바는, <strong>가중치 X 이하인 간선들만 사용해서 두 정점을 오갈 수 있나?</strong> 라는 형태의 질문과 동일합니다. 이 때 모든 쿼리를 X의 오름차순으로 정렬했다면, 각각의 쿼리에서 보게 되는 간선들의 집합이 갈수록 커지게 됩니다.</p>\n\n<p>간선들이 추가되는 상황에서 두 정점을 오가는 경로가 있는지, 즉 두 정점이 연결되어 있는지를 확인하는 좋은 자료구조로는 유니온 파인드(Union-Find, 서로소 집합Disjoint Set이라고도 합니다)가 있습니다. 가중치 순서대로 모든 간선과 쿼리를 보면서, 간선이 나오면 두 정점을 하나의 집합으로 합쳐주고, 쿼리가 나오면 두 정점이 같은 집합에 있는지를 보면 됩니다. 이 방법을 사용하면 O(Q log Q) 정렬 이후 각각의 쿼리를 O(log N) 정도의 속도로 해결할 수 있습니다.</p>\n\n<p>쿼리를 정렬하지 않고 그때 그때 결과를 알아내는 방법도 있습니다. 이 방법은 그래프의 최소 스패닝 트리(Minimum Spanning Tree)에 속하는 간선만이 중요하다는 사실에 기반합니다. 해당 사실을 사용하면, 주어진 쿼리는 <strong>트리 상의 어떠한 경로에 있는 간선들의 가중치가 모두 X 이하인가?</strong> 라는 문제로 변환되며, 이는 트리의 경로에 대한 최댓값을 빠르게 구하는 자료구조를 O(N log N)에 만들어 놓으면, 각각의 쿼리 당 O(log N)에 해결할 수 있습니다. 조금 더 어려운 도전이 필요하다면 시도해 보셔도 좋습니다. :)</p>\n\n<h3 id=\"음악-추천\">음악 추천</h3>\n\n<ul>\n  <li>제출자 211명</li>\n  <li>정답자 34명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15957\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>추천이 여러 번 이루어지고 각각의 추천마다 여러 개의 노드의 값을 갱신하는 과정을 반복할 때, 지정된 값을 넘는 시점이 언제인지를 판단하는 문제입니다. 추천 횟수는 최대 10만 번이고 각각에 대해 값이 갱신되는 노드가 최대 10만 개이므로 단순히 값을 하나씩 갱신하는 방식으로는 시간 안에 답을 구할 수 없습니다.</p>\n\n<p>트리 형태로 데이터가 주어지고, 서브트리 내의 모든 값에 일정한 값을 더하는 질의를 처리하기 위해서는 트리를 깊이 우선 탐색으로 방문하는 순서대로 원소를 나열하는 트리 순회 배열(Tree Traversal Array)을 만들고, 구간 트리(Segment Tree)를 사용하여 서브트리에 대응되는 구간의 값을 갱신하는 방식을 일반적으로 사용합니다.</p>\n\n<p>특정 시점에 노드에 부여된 가중치를 구하는 과정은 노드마다 O(log N) 시간이 걸리기 때문에, 갱신이 이루어질 때마다 가중치의 합을 구하는 방식은 매우 비효율적입니다. 가중치의 합이 목표 점수를 언제 넘게 되는지만 구하면 되기 때문에, 목표 점수를 넘는 시간에 대한 이분 탐색을 진행할 경우, 특정한 가수의 평균 점수가 목표 점수를 넘는 시간을 O((K log N + N’ log N)log T) 시간에 계산할 수 있습니다. 이 때 N’은 해당 가수가 부른 곡의 수, 즉 노드의 개수이고 T는 시간의 최대 범위인 10<sup>9</sup>입니다.</p>\n\n<p>문제에서는 각 가수 별로 목표 점수를 넘게 되는 시점을 구해야 하므로, 위 과정을 모든 가수에 대해 반복할 경우 시간 안에 답을 구하기 힘듭니다. 이때 사용할 수 있는 방법이 병렬 이분 탐색(Parallel Binary Search)입니다. 이분 탐색은 구하는 값의 상한과 하한을 정한 다음 구간의 길이를 반으로 줄여나가는 과정을 반복하는 방법인데요, 구하는 값이 여러 개인 경우 각각에 대해 상한과 하한을 저장하는 배열을 정의한 뒤 한 번 계산할 때마다 모든 구간을 각각의 범위에 맞게 절반씩 줄여나갑니다. 그러면 가수의 평균 점수를 계산하는 과정은 각 가수별로 진행해야 하지만 가중치를 부여하는 과정은 여러 번 반복할 필요가 없기 때문에 모든 가수에 대해 답을 계산하는 데 걸리는 시간이 O((K log N + N log N)log T)가 됩니다. 위 식과 비교하면 값을 갱신하는 과정의 시간 복잡도는 O(K log N log T)로 같으며, 가수별로 부른 곡의 수의 합이 N이 되므로 합을 계산하는 과정의 전체 시간이 O(N log N log T)가 됨을 알 수 있습니다.</p>\n\n<h3 id=\"프로도의-100일-준비\">프로도의 100일 준비</h3>\n\n<ul>\n  <li>제출자 122명</li>\n  <li>정답자 7명</li>\n  <li><a href=\"https://www.acmicpc.net/problem/15958\" target=\"_blank\">문제 풀러 가기</a></li>\n</ul>\n\n<p>L-모양 직각다각형은 반드시 └ 또는 ┘ 모양이어야 하며, 밑변이 x축에 붙어 있어야 합니다. 이는 주어진 도형이 히스토그램 모양이기 때문입니다.┌ 또는 ┐ 모양이 가능하다면 넓이가 더 넓은 직사각형도 가능하고, 밑변이 x축보다 위에 있다면 도형을 연장하여 x축에 붙일 수 있습니다. 그러고 나면, L-모양 직각다각형은 밑변이 x축에 붙어 있고, 서로 인접한 두 개의 직사각형이 붙어 있는 형태임을 알 수 있습니다. 이렇게 정의를 하면 정점의 수가 4와 6인 경우를 모두 고려하게 됩니다.</p>\n\n<p>가장 넓은 L-모양 직각다각형을 찾기 위하여, 역으로 두 직사각형이 붙어 있는 x좌표 x<sub>0</sub>을 고정해 봅시다. x ≤ x<sub>0</sub>인 영역과 x ≥ x<sub>0</sub>인 영역은 독립적이므로, 각각에 대해 가장 넓은 직사각형을 구한 뒤 넓이를 더하면 됩니다. 즉, x = x<sub>0</sub> 왼쪽/오른쪽 영역에서, x = x<sub>0</sub>에 붙어 있으면서 히스토그램에 들어 있는 가장 넓은 직사각형을 구하면 됩니다.</p>\n\n<p>이렇게 접근했을 때 첫 번째로 당면하는 문제는 x<sub>0</sub>이 너무 많다는 것입니다. 다행히도, x<sub>0</sub>으로 가능한 값들은 입력으로 주어진 x좌표들뿐입니다. 이는 f(x<sub>0</sub>)을 윗 문단의 상황에서 가장 넓은 L-모양 직각다각형의 넓이로 둔다면, f가 구간별로 선형인 함수(piecewise linear function)이며(연속 함수는 아닙니다), 끊기는 지점들이 입력으로 주어진 x좌표들뿐임을 관찰함으로써 알 수 있습니다.</p>\n\n<p>남은 것은 x = x<sub>0</sub> 왼쪽 영역에서, 오른쪽 변이 x = x<sub>0</sub>에 붙어 있으면서 히스토그램에 들어 있는 가장 넓은 직사각형의 넓이를 구하는 것입니다. 오른쪽 영역에서 구하는 것은 똑같이 할 수 있습니다. 문제 자체가 히스토그램에서 가장 넓은 직사각형을 구하는 상황과 굉장히 유사합니다. 이 문제는 스택을 활용해 해결할 수 있는 방법이 잘 알려져 있습니다. 이 방법을 “알고리즘 X”라고 부르겠습니다.</p>\n\n<p>알고리즘 X는 히스토그램을 왼쪽에서부터 오른쪽으로 훑습니다. 각 x좌표를 고려하는 상황에서, 스택에는 (높이 h, 해당 높이 이상이 유지되는 가장 왼쪽 x좌표 x<sub>l</sub>)의 쌍들이 들어 있습니다. 이 때, 오른쪽 변이 x = x<sub>0</sub>인 가장 넓은 직사각형을 구하기 위해 할 수 있는 가장 쉬운 생각은 스택을 모두 순회해 보는 것입니다. 스택의 원소 (h, x<sub>l</sub>)에 대해, 넓이는 h(x<sub>0</sub> - x<sub>l</sub>)입니다. 하지만 모두 순회하는 것은 굉장히 느립니다.</p>\n\n<p>그런데, 식의 꼴을 살펴보면 기울기가 h이고 y절편이 -hx<sub>l</sub>인 직선임을 알 수 있습니다. 즉, 우리가 원하는 것은 여러 개의 직선들이 있을 때, x = x<sub>0</sub>에서 최댓값을 구하는 것입니다. 컨벡스 헐 트릭(Convex Hull Trick)을 사용할 수 있을 것이라고 생각할 수 있습니다. 마침, 알고리즘 X를 생각해 보면 스택에 저장된 h는 아래에서 위로 갈수록 순증가하기 때문에, 직선의 기울기가 순증가할 때 사용할 수 있는 컨벡스 헐 트릭에도 알맞아 보입니다.</p>\n\n<p>문제는, 알고리즘 X에서 스택의 원소가 빠지기도 한다는 것입니다. 컨벡스 헐 트릭에서 추가된 직선 l에 의해 삭제된 직선들이 있을텐데, 스택에서 원소가 제거되는 과정에서 이 삭제된 직선들이 다시 복구되어야 하는 경우가 발생할 수 있습니다. 이 점을 해결하기 위해 크게 세 가지 방법이 있습니다.</p>\n<ul>\n  <li>스택을 삭제된 데이터가 보존되는 형태(Persistent Stack)로 관리합니다. 다음의 글을 참고하시면 도움이 됩니다. <a href=\"http://codeforces.com/blog/entry/51684\" target=\"_blank\">http://codeforces.com/blog/entry/51684</a></li>\n  <li>구간에 직선을 추가하고(즉, 선분을 추가하는 것), 특정 x좌표에서의 최대 y좌표를 구하는 자료구조가 있습니다(Li Chao Segment Tree). 스택의 어떤 원소 (h, x<sub>l</sub>)이 x = x<sub>r</sub>에서 제거된다고 하면, 해당 자료구조에서 [x<sub>l</sub>, x<sub>r</sub>] 구간에 y = h(x - x<sub>l</sub>)을 추가합니다. 모든 직선이 추가된 이후, 각 x좌표에서의 최댓값을 구하면 됩니다.</li>\n  <li>이 작업은 구간 트리(Segment Tree)의 각 노드에 컨벡스 헐 트릭 구조를 저장해놓는 방식으로도 구현할 수 있습니다. 추가해야 할 직선들에 대한 정보를 미리 처리한 뒤, h에 대해 오름차순 정렬하여 순서대로 추가하면 됩니다.</li>\n</ul>\n\n<h2 id=\"곧-있을-코드-페스티벌-본선을-기대해주세요\">곧 있을 코드 페스티벌 본선을 기대해주세요!</h2>\n\n<p>예선 참가자 중 우수한 성적을 거둔 64명이 본선에 진출하게 됩니다. 예선 순위표는 홈페이지(<a href=\"https://www.kakaocode.com\" target=\"_blank\">https://www.kakaocode.com</a>)에 같이 공지할 예정이니 참고하시기 바랍니다. 본선 진출자들이 즐거운 경험을 가지고 돌아갈 수 있도록, 카카오에서 열심히 준비하고 있으니 많이 기대해주세요!</p>\n"
    } 
  
  
    
,
  {
    "title"    : "404",
    "category" : "",
    "tags"     : "",
    "url"      : "/404.html",
    "date"     : "",
    "content"   : "<div style=\"text-align:center;\">\n    <h1>404 Not Found</h1>\n</div>\n"
  }
    
  
    
,
  {
    "title"    : "Authors",
    "category" : "",
    "tags"     : "",
    "url"      : "/authors/",
    "date"     : "",
    "content"   : "\n<ul>\n  <li>\n    <p><a href=\"/authors/ari\">ari</a></p>\n  </li>\n  <li>\n    <p><a href=\"/authors/cindy\">cindy</a></p>\n  </li>\n</ul>\n\n"
  }
    
  
    
  
    
,
  {
    "title"    : "회사 소개 입니다!! TITLE",
    "category" : "",
    "tags"     : "intro",
    "url"      : "/intro/",
    "date"     : "",
    "content"   : "<h2 id=\"회사-소개-입니다---제목\">회사 소개 입니다 - 제목</h2>\n"
  }
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
]
